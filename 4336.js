"use strict";(self.webpackChunkmy_application=self.webpackChunkmy_application||[]).push([[4336],{4336:(t,n,e)=>{e.r(n),e.d(n,{default:()=>o});const o='/** @type {monaco.languages.SemanticTokensLegend} */\nconst legend = {\n\ttokenTypes: [\n\t\t"comment",\n\t\t"string",\n\t\t"keyword",\n\t\t"number",\n\t\t"regexp",\n\t\t"operator",\n\t\t"namespace",\n\t\t"type",\n\t\t"struct",\n\t\t"class",\n\t\t"interface",\n\t\t"enum",\n\t\t"typeParameter",\n\t\t"function",\n\t\t"member",\n\t\t"macro",\n\t\t"variable",\n\t\t"parameter",\n\t\t"property",\n\t\t"label",\n\t],\n\ttokenModifiers: [\n\t\t"declaration",\n\t\t"documentation",\n\t\t"readonly",\n\t\t"static",\n\t\t"abstract",\n\t\t"deprecated",\n\t\t"modification",\n\t\t"async",\n\t],\n};\n\n/** @type {(type: string)=>number} */\nfunction getType(type) {\n\treturn legend.tokenTypes.indexOf(type);\n}\n\n/** @type {(modifier: string[]|string|null)=>number} */\nfunction getModifier(modifiers) {\n\tif (typeof modifiers === "string") {\n\t\tmodifiers = [modifiers];\n\t}\n\tif (Array.isArray(modifiers)) {\n\t\tlet nModifiers = 0;\n\t\tfor (let modifier of modifiers) {\n\t\t\tconst nModifier = legend.tokenModifiers.indexOf(modifier);\n\t\t\tif (nModifier > -1) {\n\t\t\t\tnModifiers |= (1 << nModifier) >>> 0;\n\t\t\t}\n\t\t}\n\t\treturn nModifiers;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nconst tokenPattern = new RegExp("([a-zA-Z]+)((?:\\\\.[a-zA-Z]+)*)", "g");\n\nmonaco.languages.registerDocumentSemanticTokensProvider("plaintext", {\n\tgetLegend: function () {\n\t\treturn legend;\n\t},\n\tprovideDocumentSemanticTokens: function (model, lastResultId, token) {\n\t\tconst lines = model.getLinesContent();\n\n\t\t/** @type {number[]} */\n\t\tconst data = [];\n\n\t\tlet prevLine = 0;\n\t\tlet prevChar = 0;\n\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tconst line = lines[i];\n\n\t\t\tfor (let match = null; (match = tokenPattern.exec(line)); ) {\n\t\t\t\t// translate token and modifiers to number representations\n\t\t\t\tlet type = getType(match[1]);\n\t\t\t\tif (type === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet modifier = match[2].length\n\t\t\t\t\t? getModifier(match[2].split(".").slice(1))\n\t\t\t\t\t: 0;\n\n\t\t\t\tdata.push(\n\t\t\t\t\t// translate line to deltaLine\n\t\t\t\t\ti - prevLine,\n\t\t\t\t\t// for the same line, translate start to deltaStart\n\t\t\t\t\tprevLine === i ? match.index - prevChar : match.index,\n\t\t\t\t\tmatch[0].length,\n\t\t\t\t\ttype,\n\t\t\t\t\tmodifier\n\t\t\t\t);\n\n\t\t\t\tprevLine = i;\n\t\t\t\tprevChar = match.index;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tdata: new Uint32Array(data),\n\t\t\tresultId: null,\n\t\t};\n\t},\n\treleaseDocumentSemanticTokens: function (resultId) {},\n});\n\n// add some missing tokens\nmonaco.editor.defineTheme("myCustomTheme", {\n\tbase: "vs",\n\tinherit: true,\n\tcolors: {},\n\trules: [\n\t\t{ token: "comment", foreground: "aaaaaa", fontStyle: "italic" },\n\t\t{ token: "keyword", foreground: "ce63eb" },\n\t\t{ token: "operator", foreground: "000000" },\n\t\t{ token: "namespace", foreground: "66afce" },\n\n\t\t{ token: "type", foreground: "1db010" },\n\t\t{ token: "struct", foreground: "0000ff" },\n\t\t{ token: "class", foreground: "0000ff", fontStyle: "bold" },\n\t\t{ token: "interface", foreground: "007700", fontStyle: "bold" },\n\t\t{ token: "enum", foreground: "0077ff", fontStyle: "bold" },\n\t\t{ token: "typeParameter", foreground: "1db010" },\n\t\t{ token: "function", foreground: "94763a" },\n\n\t\t{ token: "member", foreground: "94763a" },\n\t\t{ token: "macro", foreground: "615a60" },\n\t\t{ token: "variable", foreground: "3e5bbf" },\n\t\t{ token: "parameter", foreground: "3e5bbf" },\n\t\t{ token: "property", foreground: "3e5bbf" },\n\t\t{ token: "label", foreground: "615a60" },\n\n\t\t{ token: "type.static", fontStyle: "bold" },\n\t\t{ token: "class.static", foreground: "ff0000", fontStyle: "bold" },\n\t],\n});\n\nconst editor = monaco.editor.create(document.getElementById("container"), {\n\tvalue: [\n\t\t"Available token types:",\n\t\t"    [comment] [string] [keyword] [number] [regexp] [operator] [namespace]",\n\t\t"    [type] [struct] [class] [interface] [enum] [typeParameter] [function]",\n\t\t"    [member] [macro] [variable] [parameter] [property] [label]",\n\t\t"",\n\t\t"Available token modifiers:",\n\t\t"    [type.declaration] [type.documentation] [type.member] [type.static]",\n\t\t"    [type.abstract] [type.deprecated] [type.modification] [type.async]",\n\t\t"",\n\t\t"Some examples:",\n\t\t"    [class.static.token]     [type.static.abstract]",\n\t\t"    [class.static.token]     [type.static]",\n\t\t"",\n\t\t"    [struct]",\n\t\t"",\n\t\t"    [function.private]",\n\t\t"",\n\t\t"An error case:",\n\t\t"    [notInLegend]",\n\t].join("\\n"),\n\tlanguage: "plaintext",\n\ttheme: "myCustomTheme",\n\t// semantic tokens provider is disabled by default\n\t"semanticHighlighting.enabled": true,\n});\n'}}]);
//# sourceMappingURL=4336.js.map