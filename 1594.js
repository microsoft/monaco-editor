"use strict";(self.webpackChunkmy_application=self.webpackChunkmy_application||[]).push([[1594],{1594:(n,e,a)=>{a.r(e),a.d(e,{default:()=>i});const i='terraform {\n  required_providers {\n    aws = {\n      source  = "hashicorp/aws"\n      version = "~> 1.0.4"\n    }\n  }\n}\n\nvariable "aws_region" {}\n\nvariable "base_cidr_block" {\n  description = "A /16 CIDR range definition, such as 10.1.0.0/16, that the VPC will use"\n  default = "10.1.0.0/16"\n}\n\nvariable "availability_zones" {\n  description = "A list of availability zones in which to create subnets"\n  type = list(string)\n}\n\nprovider "aws" {\n  region = var.aws_region\n}\n\nresource "aws_vpc" "main" {\n  # Referencing the base_cidr_block variable allows the network address\n  # to be changed without modifying the configuration.\n  cidr_block = var.base_cidr_block\n}\n\nresource "aws_subnet" "az" {\n  # Create one subnet for each given availability zone.\n  count = length(var.availability_zones)\n\n  # For each subnet, use one of the specified availability zones.\n  availability_zone = var.availability_zones[count.index]\n\n  # By referencing the aws_vpc.main object, Terraform knows that the subnet\n  # must be created only after the VPC is created.\n  vpc_id = aws_vpc.main.id\n\n  # Built-in functions and operators can be used for simple transformations of\n  # values, such as computing a subnet address. Here we create a /20 prefix for\n  # each subnet, using consecutive addresses for each availability zone,\n  # such as 10.1.16.0/20 .\n  cidr_block = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index+1)\n}\n'}}]);
//# sourceMappingURL=1594.js.map