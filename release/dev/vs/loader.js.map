{"version":3,"sources":["fake","vs/loader.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"vs/loader.js","sourcesContent":["/*!-----------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.7.3(14ab24ad53d8d969e86bae0096ecc3b954d0faa0)\n * Released under the MIT license\n * https://github.com/Microsoft/vscode/blob/master/LICENSE.txt\n *-----------------------------------------------------------*/\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/*---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n * Please make sure to make edits in the .ts file at https://github.com/Microsoft/vscode-loader/\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n// Limitation: To load jquery through the loader, always require 'jquery' and add a path for it in the loader configuration\nvar _amdLoaderGlobal = this, define;\nvar AMDLoader;\n(function (AMDLoader) {\n    // ------------------------------------------------------------------------\n    // Utilities\n    function _isWindows() {\n        if (typeof navigator !== 'undefined') {\n            if (navigator.userAgent && navigator.userAgent.indexOf('Windows') >= 0) {\n                return true;\n            }\n        }\n        if (typeof process !== 'undefined') {\n            return (process.platform === 'win32');\n        }\n        return false;\n    }\n    var isWindows = _isWindows();\n    var Utilities = (function () {\n        function Utilities() {\n        }\n        /**\n         * This method does not take care of / vs \\\n         */\n        Utilities.fileUriToFilePath = function (uri) {\n            uri = decodeURI(uri);\n            if (isWindows) {\n                if (/^file:\\/\\/\\//.test(uri)) {\n                    // This is a URI without a hostname => return only the path segment\n                    return uri.substr(8);\n                }\n                if (/^file:\\/\\//.test(uri)) {\n                    return uri.substr(5);\n                }\n            }\n            else {\n                if (/^file:\\/\\//.test(uri)) {\n                    return uri.substr(7);\n                }\n            }\n            // Not sure...\n            return uri;\n        };\n        Utilities.startsWith = function (haystack, needle) {\n            return haystack.length >= needle.length && haystack.substr(0, needle.length) === needle;\n        };\n        Utilities.endsWith = function (haystack, needle) {\n            return haystack.length >= needle.length && haystack.substr(haystack.length - needle.length) === needle;\n        };\n        // only check for \"?\" before \"#\" to ensure that there is a real Query-String\n        Utilities.containsQueryString = function (url) {\n            return /^[^\\#]*\\?/gi.test(url);\n        };\n        /**\n         * Does `url` start with http:// or https:// or / ?\n         */\n        Utilities.isAbsolutePath = function (url) {\n            return (Utilities.startsWith(url, 'http://')\n                || Utilities.startsWith(url, 'https://')\n                || Utilities.startsWith(url, 'file://')\n                || Utilities.startsWith(url, '/'));\n        };\n        Utilities.forEachProperty = function (obj, callback) {\n            if (obj) {\n                var key;\n                for (key in obj) {\n                    if (obj.hasOwnProperty(key)) {\n                        callback(key, obj[key]);\n                    }\n                }\n            }\n        };\n        Utilities.isEmpty = function (obj) {\n            var isEmpty = true;\n            Utilities.forEachProperty(obj, function () {\n                isEmpty = false;\n            });\n            return isEmpty;\n        };\n        Utilities.isArray = function (obj) {\n            if (Array.isArray) {\n                return Array.isArray(obj);\n            }\n            return Object.prototype.toString.call(obj) === '[object Array]';\n        };\n        Utilities.recursiveClone = function (obj) {\n            if (!obj || typeof obj !== 'object') {\n                return obj;\n            }\n            var result = Utilities.isArray(obj) ? [] : {};\n            Utilities.forEachProperty(obj, function (key, value) {\n                if (value && typeof value === 'object') {\n                    result[key] = Utilities.recursiveClone(value);\n                }\n                else {\n                    result[key] = value;\n                }\n            });\n            return result;\n        };\n        Utilities.generateAnonymousModule = function () {\n            return '===anonymous' + (Utilities.NEXT_ANONYMOUS_ID++) + '===';\n        };\n        Utilities.isAnonymousModule = function (id) {\n            return id.indexOf('===anonymous') === 0;\n        };\n        Utilities.NEXT_ANONYMOUS_ID = 1;\n        return Utilities;\n    }());\n    AMDLoader.Utilities = Utilities;\n    var ConfigurationOptionsUtil = (function () {\n        function ConfigurationOptionsUtil() {\n        }\n        /**\n         * Ensure configuration options make sense\n         */\n        ConfigurationOptionsUtil.validateConfigurationOptions = function (options) {\n            function defaultOnError(err) {\n                if (err.errorCode === 'load') {\n                    console.error('Loading \"' + err.moduleId + '\" failed');\n                    console.error('Detail: ', err.detail);\n                    if (err.detail && err.detail.stack) {\n                        console.error(err.detail.stack);\n                    }\n                    console.error('Here are the modules that depend on it:');\n                    console.error(err.neededBy);\n                    return;\n                }\n                if (err.errorCode === 'factory') {\n                    console.error('The factory method of \"' + err.moduleId + '\" has thrown an exception');\n                    console.error(err.detail);\n                    if (err.detail && err.detail.stack) {\n                        console.error(err.detail.stack);\n                    }\n                    return;\n                }\n            }\n            options = options || {};\n            if (typeof options.baseUrl !== 'string') {\n                options.baseUrl = '';\n            }\n            if (typeof options.isBuild !== 'boolean') {\n                options.isBuild = false;\n            }\n            if (typeof options.paths !== 'object') {\n                options.paths = {};\n            }\n            if (typeof options.bundles !== 'object') {\n                options.bundles = [];\n            }\n            if (typeof options.shim !== 'object') {\n                options.shim = {};\n            }\n            if (typeof options.config !== 'object') {\n                options.config = {};\n            }\n            if (typeof options.catchError === 'undefined') {\n                // Catch errors by default in web workers, do not catch errors by default in other contexts\n                options.catchError = isWebWorker;\n            }\n            if (typeof options.urlArgs !== 'string') {\n                options.urlArgs = '';\n            }\n            if (typeof options.onError !== 'function') {\n                options.onError = defaultOnError;\n            }\n            if (typeof options.ignoreDuplicateModules !== 'object' || !Utilities.isArray(options.ignoreDuplicateModules)) {\n                options.ignoreDuplicateModules = [];\n            }\n            if (options.baseUrl.length > 0) {\n                if (!Utilities.endsWith(options.baseUrl, '/')) {\n                    options.baseUrl += '/';\n                }\n            }\n            if (!Array.isArray(options.nodeModules)) {\n                options.nodeModules = [];\n            }\n            return options;\n        };\n        ConfigurationOptionsUtil.mergeConfigurationOptions = function (overwrite, base) {\n            if (overwrite === void 0) { overwrite = null; }\n            if (base === void 0) { base = null; }\n            var result = Utilities.recursiveClone(base || {});\n            // Merge known properties and overwrite the unknown ones\n            Utilities.forEachProperty(overwrite, function (key, value) {\n                if (key === 'bundles' && typeof result.bundles !== 'undefined') {\n                    if (Utilities.isArray(value)) {\n                        // Compatibility style\n                        result.bundles = result.bundles.concat(value);\n                    }\n                    else {\n                        // AMD API style\n                        Utilities.forEachProperty(value, function (key, value) {\n                            var bundleConfiguration = {\n                                location: key,\n                                modules: value\n                            };\n                            result.bundles.push(bundleConfiguration);\n                        });\n                    }\n                }\n                else if (key === 'ignoreDuplicateModules' && typeof result.ignoreDuplicateModules !== 'undefined') {\n                    result.ignoreDuplicateModules = result.ignoreDuplicateModules.concat(value);\n                }\n                else if (key === 'paths' && typeof result.paths !== 'undefined') {\n                    Utilities.forEachProperty(value, function (key2, value2) { return result.paths[key2] = value2; });\n                }\n                else if (key === 'shim' && typeof result.shim !== 'undefined') {\n                    Utilities.forEachProperty(value, function (key2, value2) { return result.shim[key2] = value2; });\n                }\n                else if (key === 'config' && typeof result.config !== 'undefined') {\n                    Utilities.forEachProperty(value, function (key2, value2) { return result.config[key2] = value2; });\n                }\n                else {\n                    result[key] = Utilities.recursiveClone(value);\n                }\n            });\n            return ConfigurationOptionsUtil.validateConfigurationOptions(result);\n        };\n        return ConfigurationOptionsUtil;\n    }());\n    AMDLoader.ConfigurationOptionsUtil = ConfigurationOptionsUtil;\n    var Configuration = (function () {\n        function Configuration(options) {\n            this.options = ConfigurationOptionsUtil.mergeConfigurationOptions(options);\n            this._createIgnoreDuplicateModulesMap();\n            this._createSortedPathsRules();\n            this._createShimModules();\n            this._createOverwriteModuleIdToPath();\n            if (this.options.baseUrl === '') {\n                if (isNode && this.options.nodeRequire && this.options.nodeRequire.main && this.options.nodeRequire.main.filename) {\n                    var nodeMain = this.options.nodeRequire.main.filename;\n                    var dirnameIndex = Math.max(nodeMain.lastIndexOf('/'), nodeMain.lastIndexOf('\\\\'));\n                    this.options.baseUrl = nodeMain.substring(0, dirnameIndex + 1);\n                }\n                if (isNode && this.options.nodeMain) {\n                    var nodeMain = this.options.nodeMain;\n                    var dirnameIndex = Math.max(nodeMain.lastIndexOf('/'), nodeMain.lastIndexOf('\\\\'));\n                    this.options.baseUrl = nodeMain.substring(0, dirnameIndex + 1);\n                }\n            }\n        }\n        Configuration.prototype._createOverwriteModuleIdToPath = function () {\n            this.overwriteModuleIdToPath = {};\n            for (var i = 0; i < this.options.bundles.length; i++) {\n                var bundle = this.options.bundles[i];\n                var location = bundle.location;\n                if (bundle.modules) {\n                    for (var j = 0; j < bundle.modules.length; j++) {\n                        this.overwriteModuleIdToPath[bundle.modules[j]] = location;\n                    }\n                }\n            }\n        };\n        Configuration.prototype._createIgnoreDuplicateModulesMap = function () {\n            // Build a map out of the ignoreDuplicateModules array\n            this.ignoreDuplicateModulesMap = {};\n            for (var i = 0; i < this.options.ignoreDuplicateModules.length; i++) {\n                this.ignoreDuplicateModulesMap[this.options.ignoreDuplicateModules[i]] = true;\n            }\n        };\n        Configuration.prototype._createSortedPathsRules = function () {\n            var _this = this;\n            // Create an array our of the paths rules, sorted descending by length to\n            // result in a more specific -> less specific order\n            this.sortedPathsRules = [];\n            Utilities.forEachProperty(this.options.paths, function (from, to) {\n                if (!Utilities.isArray(to)) {\n                    _this.sortedPathsRules.push({\n                        from: from,\n                        to: [to]\n                    });\n                }\n                else {\n                    _this.sortedPathsRules.push({\n                        from: from,\n                        to: to\n                    });\n                }\n            });\n            this.sortedPathsRules.sort(function (a, b) {\n                return b.from.length - a.from.length;\n            });\n        };\n        Configuration.prototype._ensureShimModule1 = function (path, shimMD) {\n            // Ensure dependencies are also shimmed\n            for (var i = 0; i < shimMD.length; i++) {\n                var dependencyId = shimMD[i];\n                if (!this.shimModules.hasOwnProperty(dependencyId)) {\n                    this._ensureShimModule1(dependencyId, []);\n                }\n            }\n            this.shimModules[path] = {\n                stack: null,\n                dependencies: shimMD,\n                callback: null\n            };\n            if (this.options.isBuild) {\n                this.shimModulesStr[path] = 'null';\n            }\n        };\n        Configuration.prototype._ensureShimModule2 = function (path, shimMD) {\n            this.shimModules[path] = {\n                stack: null,\n                dependencies: shimMD.deps || [],\n                callback: function () {\n                    var depsValues = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        depsValues[_i - 0] = arguments[_i];\n                    }\n                    if (typeof shimMD.init === 'function') {\n                        var initReturnValue = shimMD.init.apply(global, depsValues);\n                        if (typeof initReturnValue !== 'undefined') {\n                            return initReturnValue;\n                        }\n                    }\n                    if (typeof shimMD.exports === 'function') {\n                        return shimMD.exports.apply(global, depsValues);\n                    }\n                    if (typeof shimMD.exports === 'string') {\n                        var pieces = shimMD.exports.split('.');\n                        var obj = global;\n                        for (var i = 0; i < pieces.length; i++) {\n                            if (obj) {\n                                obj = obj[pieces[i]];\n                            }\n                        }\n                        return obj;\n                    }\n                    return shimMD.exports || {};\n                }\n            };\n            if (this.options.isBuild) {\n                if (typeof shimMD.init === 'function') {\n                    this.shimModulesStr[path] = shimMD.init.toString();\n                }\n                else if (typeof shimMD.exports === 'function') {\n                    this.shimModulesStr[path] = shimMD.exports.toString();\n                }\n                else if (typeof shimMD.exports === 'string') {\n                    this.shimModulesStr[path] = 'function() { return this.' + shimMD.exports + '; }';\n                }\n                else {\n                    this.shimModulesStr[path] = JSON.stringify(shimMD.exports);\n                }\n            }\n        };\n        Configuration.prototype._createShimModules = function () {\n            var _this = this;\n            this.shimModules = {};\n            this.shimModulesStr = {};\n            Utilities.forEachProperty(this.options.shim, function (path, shimMD) {\n                if (!shimMD) {\n                    return;\n                }\n                if (Utilities.isArray(shimMD)) {\n                    _this._ensureShimModule1(path, shimMD);\n                    return;\n                }\n                _this._ensureShimModule2(path, shimMD);\n            });\n        };\n        /**\n         * Clone current configuration and overwrite options selectively.\n         * @param options The selective options to overwrite with.\n         * @result A new configuration\n         */\n        Configuration.prototype.cloneAndMerge = function (options) {\n            return new Configuration(ConfigurationOptionsUtil.mergeConfigurationOptions(options, this.options));\n        };\n        /**\n         * Get current options bag. Useful for passing it forward to plugins.\n         */\n        Configuration.prototype.getOptionsLiteral = function () {\n            return this.options;\n        };\n        Configuration.prototype._applyPaths = function (moduleId) {\n            var pathRule;\n            for (var i = 0, len = this.sortedPathsRules.length; i < len; i++) {\n                pathRule = this.sortedPathsRules[i];\n                if (Utilities.startsWith(moduleId, pathRule.from)) {\n                    var result = [];\n                    for (var j = 0, lenJ = pathRule.to.length; j < lenJ; j++) {\n                        result.push(pathRule.to[j] + moduleId.substr(pathRule.from.length));\n                    }\n                    return result;\n                }\n            }\n            return [moduleId];\n        };\n        Configuration.prototype._addUrlArgsToUrl = function (url) {\n            if (Utilities.containsQueryString(url)) {\n                return url + '&' + this.options.urlArgs;\n            }\n            else {\n                return url + '?' + this.options.urlArgs;\n            }\n        };\n        Configuration.prototype._addUrlArgsIfNecessaryToUrl = function (url) {\n            if (this.options.urlArgs) {\n                return this._addUrlArgsToUrl(url);\n            }\n            return url;\n        };\n        Configuration.prototype._addUrlArgsIfNecessaryToUrls = function (urls) {\n            if (this.options.urlArgs) {\n                for (var i = 0, len = urls.length; i < len; i++) {\n                    urls[i] = this._addUrlArgsToUrl(urls[i]);\n                }\n            }\n            return urls;\n        };\n        /**\n         * Transform a module id to a location. Appends .js to module ids\n         */\n        Configuration.prototype.moduleIdToPaths = function (moduleId) {\n            if (this.isBuild() && this.options.nodeModules.indexOf(moduleId) >= 0) {\n                // This is a node module and we are at build time, drop it\n                return ['empty:'];\n            }\n            var result = moduleId;\n            if (this.overwriteModuleIdToPath.hasOwnProperty(result)) {\n                result = this.overwriteModuleIdToPath[result];\n            }\n            var results;\n            if (!Utilities.endsWith(result, '.js') && !Utilities.isAbsolutePath(result)) {\n                results = this._applyPaths(result);\n                for (var i = 0, len = results.length; i < len; i++) {\n                    if (this.isBuild() && results[i] === 'empty:') {\n                        continue;\n                    }\n                    if (!Utilities.isAbsolutePath(results[i])) {\n                        results[i] = this.options.baseUrl + results[i];\n                    }\n                    if (!Utilities.endsWith(results[i], '.js') && !Utilities.containsQueryString(results[i])) {\n                        results[i] = results[i] + '.js';\n                    }\n                }\n            }\n            else {\n                if (!Utilities.endsWith(result, '.js') && !Utilities.containsQueryString(result)) {\n                    result = result + '.js';\n                }\n                results = [result];\n            }\n            return this._addUrlArgsIfNecessaryToUrls(results);\n        };\n        /**\n         * Transform a module id or url to a location.\n         */\n        Configuration.prototype.requireToUrl = function (url) {\n            var result = url;\n            if (!Utilities.isAbsolutePath(result)) {\n                result = this._applyPaths(result)[0];\n                if (!Utilities.isAbsolutePath(result)) {\n                    result = this.options.baseUrl + result;\n                }\n            }\n            return this._addUrlArgsIfNecessaryToUrl(result);\n        };\n        /**\n         * Test if `moduleId` is shimmed.\n         */\n        Configuration.prototype.isShimmed = function (moduleId) {\n            return this.shimModules.hasOwnProperty(moduleId);\n        };\n        /**\n         * Flag to indicate if current execution is as part of a build.\n         */\n        Configuration.prototype.isBuild = function () {\n            return this.options.isBuild;\n        };\n        /**\n         * Get a normalized shim definition for `moduleId`.\n         */\n        Configuration.prototype.getShimmedModuleDefine = function (moduleId) {\n            return this.shimModules[moduleId];\n        };\n        Configuration.prototype.getShimmedModulesStr = function (moduleId) {\n            return this.shimModulesStr[moduleId];\n        };\n        /**\n         * Test if module `moduleId` is expected to be defined multiple times\n         */\n        Configuration.prototype.isDuplicateMessageIgnoredFor = function (moduleId) {\n            return this.ignoreDuplicateModulesMap.hasOwnProperty(moduleId);\n        };\n        /**\n         * Get the configuration settings for the provided module id\n         */\n        Configuration.prototype.getConfigForModule = function (moduleId) {\n            if (this.options.config) {\n                return this.options.config[moduleId];\n            }\n        };\n        /**\n         * Should errors be caught when executing module factories?\n         */\n        Configuration.prototype.shouldCatchError = function () {\n            return this.options.catchError;\n        };\n        /**\n         * Should statistics be recorded?\n         */\n        Configuration.prototype.shouldRecordStats = function () {\n            return this.options.recordStats;\n        };\n        /**\n         * Forward an error to the error handler.\n         */\n        Configuration.prototype.onError = function (err) {\n            this.options.onError(err);\n        };\n        return Configuration;\n    }());\n    AMDLoader.Configuration = Configuration;\n    // ------------------------------------------------------------------------\n    // ModuleIdResolver\n    var ModuleIdResolver = (function () {\n        function ModuleIdResolver(config, fromModuleId) {\n            this._config = config;\n            var lastSlash = fromModuleId.lastIndexOf('/');\n            if (lastSlash !== -1) {\n                this.fromModulePath = fromModuleId.substr(0, lastSlash + 1);\n            }\n            else {\n                this.fromModulePath = '';\n            }\n        }\n        ModuleIdResolver.prototype.isBuild = function () {\n            return this._config.isBuild();\n        };\n        /**\n         * Normalize 'a/../name' to 'name', etc.\n         */\n        ModuleIdResolver._normalizeModuleId = function (moduleId) {\n            var r = moduleId, pattern;\n            // replace /./ => /\n            pattern = /\\/\\.\\//;\n            while (pattern.test(r)) {\n                r = r.replace(pattern, '/');\n            }\n            // replace ^./ => nothing\n            r = r.replace(/^\\.\\//g, '');\n            // replace /aa/../ => / (BUT IGNORE /../../)\n            pattern = /\\/(([^\\/])|([^\\/][^\\/\\.])|([^\\/\\.][^\\/])|([^\\/][^\\/][^\\/]+))\\/\\.\\.\\//;\n            while (pattern.test(r)) {\n                r = r.replace(pattern, '/');\n            }\n            // replace ^aa/../ => nothing (BUT IGNORE ../../)\n            r = r.replace(/^(([^\\/])|([^\\/][^\\/\\.])|([^\\/\\.][^\\/])|([^\\/][^\\/][^\\/]+))\\/\\.\\.\\//, '');\n            return r;\n        };\n        /**\n         * Resolve relative module ids\n         */\n        ModuleIdResolver.prototype.resolveModule = function (moduleId) {\n            var result = moduleId;\n            if (!Utilities.isAbsolutePath(result)) {\n                if (Utilities.startsWith(result, './') || Utilities.startsWith(result, '../')) {\n                    result = ModuleIdResolver._normalizeModuleId(this.fromModulePath + result);\n                }\n            }\n            return result;\n        };\n        /**\n         * Transform a module id to a location. Appends .js to module ids\n         */\n        ModuleIdResolver.prototype.moduleIdToPaths = function (moduleId) {\n            var r = this._config.moduleIdToPaths(moduleId);\n            if (isNode && moduleId.indexOf('/') === -1) {\n                r.push('node|' + this.fromModulePath + '|' + moduleId);\n            }\n            return r;\n        };\n        /**\n         * Transform a module id or url to a location.\n         */\n        ModuleIdResolver.prototype.requireToUrl = function (url) {\n            return this._config.requireToUrl(url);\n        };\n        /**\n         * Should errors be caught when executing module factories?\n         */\n        ModuleIdResolver.prototype.shouldCatchError = function () {\n            return this._config.shouldCatchError();\n        };\n        /**\n         * Forward an error to the error handler.\n         */\n        ModuleIdResolver.prototype.onError = function (err) {\n            this._config.onError(err);\n        };\n        return ModuleIdResolver;\n    }());\n    AMDLoader.ModuleIdResolver = ModuleIdResolver;\n    // ------------------------------------------------------------------------\n    // Module\n    var Module = (function () {\n        function Module(id, dependencies, callback, errorback, recorder, moduleIdResolver, config, defineCallStack) {\n            if (defineCallStack === void 0) { defineCallStack = null; }\n            this._id = id;\n            this._dependencies = dependencies;\n            this._dependenciesValues = [];\n            this._callback = callback;\n            this._errorback = errorback;\n            this._recorder = recorder;\n            this._moduleIdResolver = moduleIdResolver;\n            this._exports = {};\n            this._exportsPassedIn = false;\n            this._config = config;\n            this._defineCallStack = defineCallStack;\n            this._digestDependencies();\n            if (this._unresolvedDependenciesCount === 0) {\n                this._complete();\n            }\n        }\n        Module.prototype._digestDependencies = function () {\n            var _this = this;\n            // Exact count of dependencies\n            this._unresolvedDependenciesCount = this._dependencies.length;\n            // Send on to the manager only a subset of dependencies\n            // For example, 'exports' and 'module' can be fulfilled locally\n            this._normalizedDependencies = [];\n            this._managerDependencies = [];\n            this._managerDependenciesMap = {};\n            var i, len, d;\n            for (i = 0, len = this._dependencies.length; i < len; i++) {\n                d = this._dependencies[i];\n                if (!d) {\n                    // Most likely, undefined sneaked in to the dependency array\n                    // Also, IE8 interprets ['a', 'b',] as ['a', 'b', undefined]\n                    console.warn('Please check module ' + this._id + ', the dependency list looks broken');\n                    this._normalizedDependencies[i] = d;\n                    this._dependenciesValues[i] = null;\n                    this._unresolvedDependenciesCount--;\n                    continue;\n                }\n                if (d === 'exports') {\n                    // Fulfill 'exports' locally and remember that it was passed in\n                    // Later on, we will ignore the return value of the factory method\n                    this._exportsPassedIn = true;\n                    this._normalizedDependencies[i] = d;\n                    this._dependenciesValues[i] = this._exports;\n                    this._unresolvedDependenciesCount--;\n                }\n                else if (d === 'module') {\n                    // Fulfill 'module' locally\n                    this._normalizedDependencies[i] = d;\n                    this._dependenciesValues[i] = {\n                        id: this._id,\n                        config: function () { return _this._config; }\n                    };\n                    this._unresolvedDependenciesCount--;\n                }\n                else if (d === 'require') {\n                    // Request 'requre' from the manager\n                    this._normalizedDependencies[i] = d;\n                    this.addManagerDependency(d, i);\n                }\n                else {\n                    // Normalize dependency and then request it from the manager\n                    var bangIndex = d.indexOf('!');\n                    if (bangIndex >= 0) {\n                        var pluginId = d.substring(0, bangIndex);\n                        var pluginParam = d.substring(bangIndex + 1, d.length);\n                        d = this._moduleIdResolver.resolveModule(pluginId) + '!' + pluginParam;\n                    }\n                    else {\n                        d = this._moduleIdResolver.resolveModule(d);\n                    }\n                    this._normalizedDependencies[i] = d;\n                    this.addManagerDependency(d, i);\n                }\n            }\n        };\n        Module.prototype.addManagerDependency = function (dependency, index) {\n            if (this._managerDependenciesMap.hasOwnProperty(dependency)) {\n                throw new Error('Module ' + this._id + ' contains multiple times a dependency to ' + dependency);\n            }\n            this._managerDependencies.push(dependency);\n            this._managerDependenciesMap[dependency] = index;\n        };\n        /**\n         * Called by the module manager because plugin dependencies can not\n         * be normalized statically, the part after '!' can only be normalized\n         * once the plugin has loaded and its normalize logic is plugged in.\n         */\n        Module.prototype.renameDependency = function (oldDependencyId, newDependencyId) {\n            if (!this._managerDependenciesMap.hasOwnProperty(oldDependencyId)) {\n                throw new Error('Loader: Cannot rename an unknown dependency!');\n            }\n            var index = this._managerDependenciesMap[oldDependencyId];\n            delete this._managerDependenciesMap[oldDependencyId];\n            this._managerDependenciesMap[newDependencyId] = index;\n            this._normalizedDependencies[index] = newDependencyId;\n        };\n        /**\n         * Get module's id\n         */\n        Module.prototype.getId = function () {\n            return this._id;\n        };\n        /**\n         * Get the module id resolver associated with this module\n         */\n        Module.prototype.getModuleIdResolver = function () {\n            return this._moduleIdResolver;\n        };\n        Module.prototype.isExportsPassedIn = function () {\n            return this._exportsPassedIn;\n        };\n        Module.prototype.getExports = function () {\n            return this._exports;\n        };\n        /**\n         * Get the initial dependencies (resolved).\n         * Does not account for any renames\n         */\n        Module.prototype.getDependencies = function () {\n            return this._managerDependencies;\n        };\n        Module.prototype.getNormalizedDependencies = function () {\n            return this._normalizedDependencies;\n        };\n        Module.prototype.getDefineCallStack = function () {\n            return this._defineCallStack;\n        };\n        Module.prototype._invokeFactory = function () {\n            if (this._moduleIdResolver.isBuild() && !Utilities.isAnonymousModule(this._id)) {\n                return {\n                    returnedValue: null,\n                    producedError: null\n                };\n            }\n            var producedError = null, returnedValue = null;\n            if (this._moduleIdResolver.shouldCatchError()) {\n                try {\n                    returnedValue = this._callback.apply(global, this._dependenciesValues);\n                }\n                catch (e) {\n                    producedError = e;\n                }\n                finally {\n                }\n            }\n            else {\n                returnedValue = this._callback.apply(global, this._dependenciesValues);\n            }\n            return {\n                returnedValue: returnedValue,\n                producedError: producedError\n            };\n        };\n        Module.prototype._complete = function () {\n            var producedError = null;\n            if (this._callback) {\n                if (typeof this._callback === 'function') {\n                    this._recorder.record(LoaderEventType.BeginInvokeFactory, this._id);\n                    var r = this._invokeFactory();\n                    producedError = r.producedError;\n                    this._recorder.record(LoaderEventType.EndInvokeFactory, this._id);\n                    if (!producedError && typeof r.returnedValue !== 'undefined' && (!this._exportsPassedIn || Utilities.isEmpty(this._exports))) {\n                        this._exports = r.returnedValue;\n                    }\n                }\n                else {\n                    this._exports = this._callback;\n                }\n            }\n            if (producedError) {\n                this.getModuleIdResolver().onError({\n                    errorCode: 'factory',\n                    moduleId: this._id,\n                    detail: producedError\n                });\n            }\n        };\n        /**\n         * Release references used while resolving module\n         */\n        Module.prototype.cleanUp = function () {\n            if (this._moduleIdResolver && !this._moduleIdResolver.isBuild()) {\n                this._normalizedDependencies = null;\n                this._moduleIdResolver = null;\n            }\n            this._dependencies = null;\n            this._dependenciesValues = null;\n            this._callback = null;\n            this._managerDependencies = null;\n            this._managerDependenciesMap = null;\n        };\n        /**\n         * One of the direct dependencies or a transitive dependency has failed to load.\n         */\n        Module.prototype.onDependencyError = function (err) {\n            if (this._errorback) {\n                this._errorback(err);\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Resolve a dependency with a value.\n         */\n        Module.prototype.resolveDependency = function (id, value) {\n            if (!this._managerDependenciesMap.hasOwnProperty(id)) {\n                throw new Error('Cannot resolve a dependency I do not have!');\n            }\n            this._dependenciesValues[this._managerDependenciesMap[id]] = value;\n            // Prevent resolving the same dependency twice\n            delete this._managerDependenciesMap[id];\n            this._unresolvedDependenciesCount--;\n            if (this._unresolvedDependenciesCount === 0) {\n                this._complete();\n            }\n        };\n        /**\n         * Is the current module complete?\n         */\n        Module.prototype.isComplete = function () {\n            return this._unresolvedDependenciesCount === 0;\n        };\n        return Module;\n    }());\n    AMDLoader.Module = Module;\n    // ------------------------------------------------------------------------\n    // LoaderEvent\n    (function (LoaderEventType) {\n        LoaderEventType[LoaderEventType[\"LoaderAvailable\"] = 1] = \"LoaderAvailable\";\n        LoaderEventType[LoaderEventType[\"BeginLoadingScript\"] = 10] = \"BeginLoadingScript\";\n        LoaderEventType[LoaderEventType[\"EndLoadingScriptOK\"] = 11] = \"EndLoadingScriptOK\";\n        LoaderEventType[LoaderEventType[\"EndLoadingScriptError\"] = 12] = \"EndLoadingScriptError\";\n        LoaderEventType[LoaderEventType[\"BeginInvokeFactory\"] = 21] = \"BeginInvokeFactory\";\n        LoaderEventType[LoaderEventType[\"EndInvokeFactory\"] = 22] = \"EndInvokeFactory\";\n        LoaderEventType[LoaderEventType[\"NodeBeginEvaluatingScript\"] = 31] = \"NodeBeginEvaluatingScript\";\n        LoaderEventType[LoaderEventType[\"NodeEndEvaluatingScript\"] = 32] = \"NodeEndEvaluatingScript\";\n        LoaderEventType[LoaderEventType[\"NodeBeginNativeRequire\"] = 33] = \"NodeBeginNativeRequire\";\n        LoaderEventType[LoaderEventType[\"NodeEndNativeRequire\"] = 34] = \"NodeEndNativeRequire\";\n    })(AMDLoader.LoaderEventType || (AMDLoader.LoaderEventType = {}));\n    var LoaderEventType = AMDLoader.LoaderEventType;\n    function getHighPerformanceTimestamp() {\n        return (hasPerformanceNow ? global.performance.now() : Date.now());\n    }\n    var LoaderEvent = (function () {\n        function LoaderEvent(type, detail, timestamp) {\n            this.type = type;\n            this.detail = detail;\n            this.timestamp = timestamp;\n        }\n        return LoaderEvent;\n    }());\n    AMDLoader.LoaderEvent = LoaderEvent;\n    var LoaderEventRecorder = (function () {\n        function LoaderEventRecorder(loaderAvailableTimestamp) {\n            this._events = [new LoaderEvent(LoaderEventType.LoaderAvailable, '', loaderAvailableTimestamp)];\n        }\n        LoaderEventRecorder.prototype.record = function (type, detail) {\n            this._events.push(new LoaderEvent(type, detail, getHighPerformanceTimestamp()));\n        };\n        LoaderEventRecorder.prototype.getEvents = function () {\n            return this._events;\n        };\n        return LoaderEventRecorder;\n    }());\n    AMDLoader.LoaderEventRecorder = LoaderEventRecorder;\n    var NullLoaderEventRecorder = (function () {\n        function NullLoaderEventRecorder() {\n        }\n        NullLoaderEventRecorder.prototype.record = function (type, detail) {\n            // Nothing to do\n        };\n        NullLoaderEventRecorder.prototype.getEvents = function () {\n            return [];\n        };\n        NullLoaderEventRecorder.INSTANCE = new NullLoaderEventRecorder();\n        return NullLoaderEventRecorder;\n    }());\n    AMDLoader.NullLoaderEventRecorder = NullLoaderEventRecorder;\n    var ModuleManager = (function () {\n        function ModuleManager(scriptLoader) {\n            this._recorder = null;\n            this._config = new Configuration();\n            this._scriptLoader = scriptLoader;\n            this._modules = {};\n            this._knownModules = {};\n            this._inverseDependencies = {};\n            this._dependencies = {};\n            this._inversePluginDependencies = {};\n            this._queuedDefineCalls = [];\n            this._loadingScriptsCount = 0;\n            this._resolvedScriptPaths = {};\n            this._checksums = {};\n        }\n        ModuleManager._findRelevantLocationInStack = function (needle, stack) {\n            var normalize = function (str) { return str.replace(/\\\\/g, '/'); };\n            var normalizedPath = normalize(needle);\n            var stackPieces = stack.split(/\\n/);\n            for (var i = 0; i < stackPieces.length; i++) {\n                var m = stackPieces[i].match(/(.*):(\\d+):(\\d+)\\)?$/);\n                if (m) {\n                    var stackPath = m[1];\n                    var stackLine = m[2];\n                    var stackColumn = m[3];\n                    var trimPathOffset = Math.max(stackPath.lastIndexOf(' ') + 1, stackPath.lastIndexOf('(') + 1);\n                    stackPath = stackPath.substr(trimPathOffset);\n                    stackPath = normalize(stackPath);\n                    if (stackPath === normalizedPath) {\n                        var r = {\n                            line: parseInt(stackLine, 10),\n                            col: parseInt(stackColumn, 10)\n                        };\n                        if (r.line === 1) {\n                            r.col -= '(function (require, define, __filename, __dirname) { '.length;\n                        }\n                        return r;\n                    }\n                }\n            }\n            throw new Error('Could not correlate define call site for needle ' + needle);\n        };\n        ModuleManager.prototype.getBuildInfo = function () {\n            var _this = this;\n            if (!this._config.isBuild()) {\n                return null;\n            }\n            return Object.keys(this._modules).map(function (moduleId) {\n                var m = _this._modules[moduleId];\n                var location = _this._resolvedScriptPaths[moduleId] || null;\n                var defineStack = m.getDefineCallStack();\n                return {\n                    id: moduleId,\n                    path: location,\n                    defineLocation: (location && defineStack ? ModuleManager._findRelevantLocationInStack(location, defineStack) : null),\n                    dependencies: m.getNormalizedDependencies(),\n                    shim: (_this._config.isShimmed(moduleId) ? _this._config.getShimmedModulesStr(moduleId) : null),\n                    exports: m.getExports()\n                };\n            });\n        };\n        ModuleManager.prototype.getRecorder = function () {\n            if (!this._recorder) {\n                if (this._config.shouldRecordStats()) {\n                    this._recorder = new LoaderEventRecorder(loaderAvailableTimestamp);\n                }\n                else {\n                    this._recorder = NullLoaderEventRecorder.INSTANCE;\n                }\n            }\n            return this._recorder;\n        };\n        ModuleManager.prototype.getLoaderEvents = function () {\n            return this.getRecorder().getEvents();\n        };\n        ModuleManager.prototype.recordChecksum = function (scriptSrc, checksum) {\n            this._checksums[scriptSrc] = checksum;\n        };\n        ModuleManager.prototype.getChecksums = function () {\n            return this._checksums;\n        };\n        /**\n         * Defines a module.\n         * @param id @see defineModule\n         * @param dependencies @see defineModule\n         * @param callback @see defineModule\n         */\n        ModuleManager.prototype.enqueueDefineModule = function (id, dependencies, callback) {\n            if (this._loadingScriptsCount === 0) {\n                // There are no scripts currently loading, so no load event will be fired, so the queue will not be consumed\n                this.defineModule(id, dependencies, callback, null, null);\n            }\n            else {\n                this._queuedDefineCalls.push({\n                    id: id,\n                    stack: null,\n                    dependencies: dependencies,\n                    callback: callback\n                });\n            }\n        };\n        /**\n         * Defines an anonymous module (without an id). Its name will be resolved as we receive a callback from the scriptLoader.\n         * @param dependecies @see defineModule\n         * @param callback @see defineModule\n         */\n        ModuleManager.prototype.enqueueDefineAnonymousModule = function (dependencies, callback) {\n            var stack = null;\n            if (this._config.isBuild()) {\n                stack = (new Error('StackLocation')).stack;\n            }\n            this._queuedDefineCalls.push({\n                id: null,\n                stack: stack,\n                dependencies: dependencies,\n                callback: callback\n            });\n        };\n        /**\n         * Creates a module and stores it in _modules. The manager will immediately begin resolving its dependencies.\n         * @param id An unique and absolute id of the module. This must not collide with another module's id\n         * @param dependencies An array with the dependencies of the module. Special keys are: \"require\", \"exports\" and \"module\"\n         * @param callback if callback is a function, it will be called with the resolved dependencies. if callback is an object, it will be considered as the exports of the module.\n         */\n        ModuleManager.prototype.defineModule = function (id, dependencies, callback, errorback, stack, moduleIdResolver) {\n            if (moduleIdResolver === void 0) { moduleIdResolver = new ModuleIdResolver(this._config, id); }\n            if (this._modules.hasOwnProperty(id)) {\n                if (!this._config.isDuplicateMessageIgnoredFor(id)) {\n                    console.warn('Duplicate definition of module \\'' + id + '\\'');\n                }\n                // Super important! Completely ignore duplicate module definition\n                return;\n            }\n            var moduleConfig = this._config.getConfigForModule(id);\n            var m = new Module(id, dependencies, callback, errorback, this.getRecorder(), moduleIdResolver, moduleConfig, stack);\n            this._modules[id] = m;\n            // Resolving of dependencies is immediate (not in a timeout). If there's a need to support a packer that concatenates in an\n            // unordered manner, in order to finish processing the file, execute the following method in a timeout\n            this._resolve(m);\n        };\n        ModuleManager.prototype._relativeRequire = function (moduleIdResolver, dependencies, callback, errorback) {\n            if (typeof dependencies === 'string') {\n                return this.synchronousRequire(dependencies, moduleIdResolver);\n            }\n            this.defineModule(Utilities.generateAnonymousModule(), dependencies, callback, errorback, null, moduleIdResolver);\n        };\n        /**\n         * Require synchronously a module by its absolute id. If the module is not loaded, an exception will be thrown.\n         * @param id The unique and absolute id of the required module\n         * @return The exports of module 'id'\n         */\n        ModuleManager.prototype.synchronousRequire = function (id, moduleIdResolver) {\n            if (moduleIdResolver === void 0) { moduleIdResolver = new ModuleIdResolver(this._config, id); }\n            var moduleId = moduleIdResolver.resolveModule(id);\n            var bangIndex = moduleId.indexOf('!');\n            if (bangIndex >= 0) {\n                // This is a synchronous require for a plugin dependency, so be sure to normalize the pluginParam (the piece after '!')\n                var pluginId = moduleId.substring(0, bangIndex), pluginParam = moduleId.substring(bangIndex + 1, moduleId.length), plugin = {};\n                if (this._modules.hasOwnProperty(pluginId)) {\n                    plugin = this._modules[pluginId];\n                }\n                // Helper to normalize the part which comes after '!'\n                var normalize = function (_arg) {\n                    return moduleIdResolver.resolveModule(_arg);\n                };\n                if (typeof plugin.normalize === 'function') {\n                    pluginParam = plugin.normalize(pluginParam, normalize);\n                }\n                else {\n                    pluginParam = normalize(pluginParam);\n                }\n                moduleId = pluginId + '!' + pluginParam;\n            }\n            if (!this._modules.hasOwnProperty(moduleId)) {\n                throw new Error('Check dependency list! Synchronous require cannot resolve module \\'' + moduleId + '\\'. This is the first mention of this module!');\n            }\n            var m = this._modules[moduleId];\n            if (!m.isComplete()) {\n                throw new Error('Check dependency list! Synchronous require cannot resolve module \\'' + moduleId + '\\'. This module has not been resolved completely yet.');\n            }\n            return m.getExports();\n        };\n        ModuleManager.prototype.configure = function (params, shouldOverwrite) {\n            var oldShouldRecordStats = this._config.shouldRecordStats();\n            if (shouldOverwrite) {\n                this._config = new Configuration(params);\n            }\n            else {\n                this._config = this._config.cloneAndMerge(params);\n            }\n            if (this._config.shouldRecordStats() && !oldShouldRecordStats) {\n                this._recorder = null;\n            }\n        };\n        ModuleManager.prototype.getConfigurationOptions = function () {\n            return this._config.getOptionsLiteral();\n        };\n        /**\n         * Callback from the scriptLoader when a module has been loaded.\n         * This means its code is available and has been executed.\n         */\n        ModuleManager.prototype._onLoad = function (id) {\n            var defineCall;\n            this._loadingScriptsCount--;\n            if (this._config.isShimmed(id)) {\n                // Do not consume queue, might end up consuming a module that is later expected\n                // If a shimmed module has loaded, create a define call for it\n                defineCall = this._config.getShimmedModuleDefine(id);\n                this.defineModule(id, defineCall.dependencies, defineCall.callback, null, defineCall.stack);\n            }\n            else {\n                if (this._queuedDefineCalls.length === 0) {\n                    // Loaded a file and it didn't call `define`\n                    this._loadingScriptsCount++;\n                    this._onLoadError(id, new Error('No define call received from module ' + id + '.'));\n                }\n                else {\n                    // Consume queue until first anonymous define call\n                    // or until current id is found in the queue\n                    while (this._queuedDefineCalls.length > 0) {\n                        defineCall = this._queuedDefineCalls.shift();\n                        if (defineCall.id === id || defineCall.id === null) {\n                            // Hit an anonymous define call or its own define call\n                            defineCall.id = id;\n                            this.defineModule(defineCall.id, defineCall.dependencies, defineCall.callback, null, defineCall.stack);\n                            break;\n                        }\n                        else {\n                            // Hit other named define calls\n                            this.defineModule(defineCall.id, defineCall.dependencies, defineCall.callback, null, defineCall.stack);\n                        }\n                    }\n                }\n            }\n            if (this._loadingScriptsCount === 0) {\n                // No more on loads will be triggered, so make sure queue is empty\n                while (this._queuedDefineCalls.length > 0) {\n                    defineCall = this._queuedDefineCalls.shift();\n                    if (defineCall.id === null) {\n                        console.warn('Found an unmatched anonymous define call in the define queue. Ignoring it!');\n                        console.warn(defineCall.callback);\n                    }\n                    else {\n                        // Hit other named define calls\n                        this.defineModule(defineCall.id, defineCall.dependencies, defineCall.callback, null, defineCall.stack);\n                    }\n                }\n            }\n        };\n        /**\n         * Callback from the scriptLoader when a module hasn't been loaded.\n         * This means that the script was not found (e.g. 404) or there was an error in the script.\n         */\n        ModuleManager.prototype._onLoadError = function (id, err) {\n            this._loadingScriptsCount--;\n            var error = {\n                errorCode: 'load',\n                moduleId: id,\n                neededBy: (this._inverseDependencies[id] ? this._inverseDependencies[id].slice(0) : []),\n                detail: err\n            };\n            // Find any 'local' error handlers, walk the entire chain of inverse dependencies if necessary.\n            var seenModuleId = {}, queueElement, someoneNotified = false, queue = [];\n            queue.push(id);\n            seenModuleId[id] = true;\n            while (queue.length > 0) {\n                queueElement = queue.shift();\n                if (this._modules[queueElement]) {\n                    someoneNotified = this._modules[queueElement].onDependencyError(error) || someoneNotified;\n                }\n                if (this._inverseDependencies[queueElement]) {\n                    for (var i = 0, len = this._inverseDependencies[queueElement].length; i < len; i++) {\n                        if (!seenModuleId.hasOwnProperty(this._inverseDependencies[queueElement][i])) {\n                            queue.push(this._inverseDependencies[queueElement][i]);\n                            seenModuleId[this._inverseDependencies[queueElement][i]] = true;\n                        }\n                    }\n                }\n            }\n            if (!someoneNotified) {\n                this._config.onError(error);\n            }\n        };\n        /**\n         * Module id has been loaded completely, its exports are available.\n         * @param id module's id\n         * @param exports module's exports\n         */\n        ModuleManager.prototype._onModuleComplete = function (id, exports) {\n            var i, len, inverseDependencyId, inverseDependency;\n            // Clean up module's dependencies since module is now complete\n            delete this._dependencies[id];\n            if (this._inverseDependencies.hasOwnProperty(id)) {\n                // Fetch and clear inverse dependencies\n                var inverseDependencies = this._inverseDependencies[id];\n                delete this._inverseDependencies[id];\n                // Resolve one inverse dependency at a time, always\n                // on the lookout for a completed module.\n                for (i = 0, len = inverseDependencies.length; i < len; i++) {\n                    inverseDependencyId = inverseDependencies[i];\n                    inverseDependency = this._modules[inverseDependencyId];\n                    inverseDependency.resolveDependency(id, exports);\n                    if (inverseDependency.isComplete()) {\n                        this._onModuleComplete(inverseDependencyId, inverseDependency.getExports());\n                    }\n                }\n            }\n            if (this._inversePluginDependencies.hasOwnProperty(id)) {\n                // This module is used as a plugin at least once\n                // Fetch and clear these inverse plugin dependencies\n                var inversePluginDependencies = this._inversePluginDependencies[id];\n                delete this._inversePluginDependencies[id];\n                // Resolve plugin dependencies one at a time\n                for (i = 0, len = inversePluginDependencies.length; i < len; i++) {\n                    var inversePluginDependencyId = inversePluginDependencies[i].moduleId;\n                    var inversePluginDependency = this._modules[inversePluginDependencyId];\n                    this._resolvePluginDependencySync(inversePluginDependencyId, inversePluginDependencies[i].dependencyId, exports);\n                    // Anonymous modules might already be gone at this point\n                    if (inversePluginDependency.isComplete()) {\n                        this._onModuleComplete(inversePluginDependencyId, inversePluginDependency.getExports());\n                    }\n                }\n            }\n            if (Utilities.isAnonymousModule(id)) {\n                // Clean up references to anonymous modules, to prevent memory leaks\n                delete this._modules[id];\n                delete this._dependencies[id];\n            }\n            else {\n                this._modules[id].cleanUp();\n            }\n        };\n        /**\n         * Walks (recursively) the dependencies of 'from' in search of 'to'.\n         * Returns true if there is such a path or false otherwise.\n         * @param from Module id to start at\n         * @param to Module id to look for\n         */\n        ModuleManager.prototype._hasDependencyPath = function (from, to) {\n            var i, len, inQueue = {}, queue = [], element, dependencies, dependency;\n            // Insert 'from' in queue\n            queue.push(from);\n            inQueue[from] = true;\n            while (queue.length > 0) {\n                // Pop first inserted element of queue\n                element = queue.shift();\n                if (this._dependencies.hasOwnProperty(element)) {\n                    dependencies = this._dependencies[element];\n                    // Walk the element's dependencies\n                    for (i = 0, len = dependencies.length; i < len; i++) {\n                        dependency = dependencies[i];\n                        if (dependency === to) {\n                            // There is a path to 'to'\n                            return true;\n                        }\n                        if (!inQueue.hasOwnProperty(dependency)) {\n                            // Insert 'dependency' in queue\n                            inQueue[dependency] = true;\n                            queue.push(dependency);\n                        }\n                    }\n                }\n            }\n            // There is no path to 'to'\n            return false;\n        };\n        /**\n         * Walks (recursively) the dependencies of 'from' in search of 'to'.\n         * Returns cycle as array.\n         * @param from Module id to start at\n         * @param to Module id to look for\n         */\n        ModuleManager.prototype._findCyclePath = function (from, to, depth) {\n            if (from === to || depth === 50) {\n                return [from];\n            }\n            if (!this._dependencies.hasOwnProperty(from)) {\n                return null;\n            }\n            var path, dependencies = this._dependencies[from];\n            // Walk the element's dependencies\n            for (var i = 0, len = dependencies.length; i < len; i++) {\n                path = this._findCyclePath(dependencies[i], to, depth + 1);\n                if (path !== null) {\n                    path.push(from);\n                    return path;\n                }\n            }\n            return null;\n        };\n        /**\n         * Create the local 'require' that is passed into modules\n         */\n        ModuleManager.prototype._createRequire = function (moduleIdResolver) {\n            var _this = this;\n            var result = (function (dependencies, callback, errorback) {\n                return _this._relativeRequire(moduleIdResolver, dependencies, callback, errorback);\n            });\n            result.toUrl = function (id) {\n                return moduleIdResolver.requireToUrl(moduleIdResolver.resolveModule(id));\n            };\n            result.getStats = function () {\n                return _this.getLoaderEvents();\n            };\n            result.getChecksums = function () {\n                return _this.getChecksums();\n            };\n            result.__$__nodeRequire = global.nodeRequire;\n            return result;\n        };\n        /**\n         * Resolve a plugin dependency with the plugin loaded & complete\n         * @param moduleId The module that has this dependency\n         * @param dependencyId The semi-normalized dependency that appears in the module. e.g. 'vs/css!./mycssfile'. Only the plugin part (before !) is normalized\n         * @param plugin The plugin (what the plugin exports)\n         */\n        ModuleManager.prototype._resolvePluginDependencySync = function (moduleId, dependencyId, plugin) {\n            var _this = this;\n            var m = this._modules[moduleId], moduleIdResolver = m.getModuleIdResolver(), bangIndex = dependencyId.indexOf('!'), pluginId = dependencyId.substring(0, bangIndex), pluginParam = dependencyId.substring(bangIndex + 1, dependencyId.length);\n            // Helper to normalize the part which comes after '!'\n            var normalize = function (_arg) {\n                return moduleIdResolver.resolveModule(_arg);\n            };\n            if (typeof plugin.normalize === 'function') {\n                pluginParam = plugin.normalize(pluginParam, normalize);\n            }\n            else {\n                pluginParam = normalize(pluginParam);\n            }\n            if (!plugin.dynamic) {\n                // Now normalize the entire dependency\n                var oldDependencyId = dependencyId;\n                dependencyId = pluginId + '!' + pluginParam;\n                // Let the module know that the dependency has been normalized so it can update its internal state\n                m.renameDependency(oldDependencyId, dependencyId);\n                this._resolveDependency(moduleId, dependencyId, function (moduleId) {\n                    // Delegate the loading of the resource to the plugin\n                    var load = (function (value) {\n                        _this.defineModule(dependencyId, [], value, null, null);\n                    });\n                    load.error = function (err) {\n                        _this._config.onError({\n                            errorCode: 'load',\n                            moduleId: dependencyId,\n                            neededBy: (_this._inverseDependencies[dependencyId] ? _this._inverseDependencies[dependencyId].slice(0) : []),\n                            detail: err\n                        });\n                    };\n                    plugin.load(pluginParam, _this._createRequire(moduleIdResolver), load, _this._config.getOptionsLiteral());\n                });\n            }\n            else {\n                // This plugin is dynamic and does not want the loader to cache anything on its behalf\n                // Delegate the loading of the resource to the plugin\n                var load = (function (value) {\n                    m.resolveDependency(dependencyId, value);\n                    if (m.isComplete()) {\n                        _this._onModuleComplete(moduleId, m.getExports());\n                    }\n                });\n                load.error = function (err) {\n                    _this._config.onError({\n                        errorCode: 'load',\n                        moduleId: dependencyId,\n                        neededBy: [moduleId],\n                        detail: err\n                    });\n                };\n                plugin.load(pluginParam, this._createRequire(moduleIdResolver), load, this._config.getOptionsLiteral());\n            }\n        };\n        /**\n         * Resolve a plugin dependency with the plugin not loaded or not complete yet\n         * @param moduleId The module that has this dependency\n         * @param dependencyId The semi-normalized dependency that appears in the module. e.g. 'vs/css!./mycssfile'. Only the plugin part (before !) is normalized\n         */\n        ModuleManager.prototype._resolvePluginDependencyAsync = function (moduleId, dependencyId) {\n            var m = this._modules[moduleId], bangIndex = dependencyId.indexOf('!'), pluginId = dependencyId.substring(0, bangIndex);\n            // Record dependency for when the plugin gets loaded\n            this._inversePluginDependencies[pluginId] = this._inversePluginDependencies[pluginId] || [];\n            this._inversePluginDependencies[pluginId].push({\n                moduleId: moduleId,\n                dependencyId: dependencyId\n            });\n            if (!this._modules.hasOwnProperty(pluginId) && !this._knownModules.hasOwnProperty(pluginId)) {\n                // This is the first mention of module 'pluginId', so load it\n                this._knownModules[pluginId] = true;\n                this._loadModule(m.getModuleIdResolver(), pluginId);\n            }\n        };\n        /**\n         * Resolve a plugin dependency\n         * @param moduleId The module that has this dependency\n         * @param dependencyId The semi-normalized dependency that appears in the module. e.g. 'vs/css!./mycssfile'. Only the plugin part (before !) is normalized\n         */\n        ModuleManager.prototype._resolvePluginDependency = function (moduleId, dependencyId) {\n            var bangIndex = dependencyId.indexOf('!'), pluginId = dependencyId.substring(0, bangIndex);\n            if (this._modules.hasOwnProperty(pluginId) && this._modules[pluginId].isComplete()) {\n                // Plugin has already been loaded & resolved\n                this._resolvePluginDependencySync(moduleId, dependencyId, this._modules[pluginId].getExports());\n            }\n            else {\n                // Plugin is not loaded or not resolved\n                this._resolvePluginDependencyAsync(moduleId, dependencyId);\n            }\n        };\n        /**\n         * Resolve a module dependency to a shimmed module and delegate the loading to loadCallback.\n         * @param moduleId The module that has this dependency\n         * @param dependencyId The normalized dependency that appears in the module -- this module is shimmed\n         * @param loadCallback Callback that will be called to trigger the loading of 'dependencyId' if needed\n         */\n        ModuleManager.prototype._resolveShimmedDependency = function (moduleId, dependencyId, loadCallback) {\n            // If a shimmed module has dependencies, we must first load those dependencies\n            // and only when those are loaded we can load the shimmed module.\n            // To achieve this, we inject a module definition with those dependencies\n            // and from its factory method we really load the shimmed module.\n            var defineInfo = this._config.getShimmedModuleDefine(dependencyId);\n            if (defineInfo.dependencies.length > 0) {\n                this.defineModule(Utilities.generateAnonymousModule(), defineInfo.dependencies, function () { return loadCallback(dependencyId); }, null, null, new ModuleIdResolver(this._config, dependencyId));\n            }\n            else {\n                loadCallback(dependencyId);\n            }\n        };\n        /**\n         * Resolve a module dependency and delegate the loading to loadCallback\n         * @param moduleId The module that has this dependency\n         * @param dependencyId The normalized dependency that appears in the module\n         * @param loadCallback Callback that will be called to trigger the loading of 'dependencyId' if needed\n         */\n        ModuleManager.prototype._resolveDependency = function (moduleId, dependencyId, loadCallback) {\n            var m = this._modules[moduleId];\n            if (this._modules.hasOwnProperty(dependencyId) && this._modules[dependencyId].isComplete()) {\n                // Dependency has already been loaded & resolved\n                m.resolveDependency(dependencyId, this._modules[dependencyId].getExports());\n            }\n            else {\n                // Dependency is not loaded or not resolved\n                // Record dependency\n                this._dependencies[moduleId].push(dependencyId);\n                if (this._hasDependencyPath(dependencyId, moduleId)) {\n                    console.warn('There is a dependency cycle between \\'' + dependencyId + '\\' and \\'' + moduleId + '\\'. The cyclic path follows:');\n                    var cyclePath = this._findCyclePath(dependencyId, moduleId, 0);\n                    cyclePath.reverse();\n                    cyclePath.push(dependencyId);\n                    console.warn(cyclePath.join(' => \\n'));\n                    // Break the cycle\n                    var dependency = this._modules.hasOwnProperty(dependencyId) ? this._modules[dependencyId] : null;\n                    var dependencyValue;\n                    if (dependency && dependency.isExportsPassedIn()) {\n                        // If dependency uses 'exports', then resolve it with that object\n                        dependencyValue = dependency.getExports();\n                    }\n                    // Resolve dependency with undefined or with 'exports' object\n                    m.resolveDependency(dependencyId, dependencyValue);\n                }\n                else {\n                    // Since we are actually waiting for this dependency,\n                    // record inverse dependency\n                    this._inverseDependencies[dependencyId] = this._inverseDependencies[dependencyId] || [];\n                    this._inverseDependencies[dependencyId].push(moduleId);\n                    if (!this._modules.hasOwnProperty(dependencyId) && !this._knownModules.hasOwnProperty(dependencyId)) {\n                        // This is the first mention of module 'dependencyId', so load it\n                        // Mark this module as loaded so we don't hit this case again\n                        this._knownModules[dependencyId] = true;\n                        if (this._config.isShimmed(dependencyId)) {\n                            this._resolveShimmedDependency(moduleId, dependencyId, loadCallback);\n                        }\n                        else {\n                            loadCallback(dependencyId);\n                        }\n                    }\n                }\n            }\n        };\n        ModuleManager.prototype._loadModule = function (anyModuleIdResolver, moduleId) {\n            var _this = this;\n            this._loadingScriptsCount++;\n            var paths = anyModuleIdResolver.moduleIdToPaths(moduleId);\n            var lastPathIndex = -1;\n            var loadNextPath = function (err) {\n                lastPathIndex++;\n                if (lastPathIndex >= paths.length) {\n                    // No more paths to try\n                    _this._onLoadError(moduleId, err);\n                }\n                else {\n                    var currentPath = paths[lastPathIndex];\n                    var recorder = _this.getRecorder();\n                    if (_this._config.isBuild() && currentPath === 'empty:') {\n                        _this._resolvedScriptPaths[moduleId] = currentPath;\n                        _this.enqueueDefineModule(moduleId, [], null);\n                        _this._onLoad(moduleId);\n                        return;\n                    }\n                    recorder.record(LoaderEventType.BeginLoadingScript, currentPath);\n                    _this._scriptLoader.load(currentPath, function () {\n                        if (_this._config.isBuild()) {\n                            _this._resolvedScriptPaths[moduleId] = currentPath;\n                        }\n                        recorder.record(LoaderEventType.EndLoadingScriptOK, currentPath);\n                        _this._onLoad(moduleId);\n                    }, function (err) {\n                        recorder.record(LoaderEventType.EndLoadingScriptError, currentPath);\n                        loadNextPath(err);\n                    }, recorder);\n                }\n            };\n            loadNextPath(null);\n        };\n        /**\n         * Examine the dependencies of module 'module' and resolve them as needed.\n         */\n        ModuleManager.prototype._resolve = function (m) {\n            var _this = this;\n            var i, len, id, dependencies, dependencyId, moduleIdResolver;\n            id = m.getId();\n            dependencies = m.getDependencies();\n            moduleIdResolver = m.getModuleIdResolver();\n            this._dependencies[id] = [];\n            var loadCallback = function (moduleId) { return _this._loadModule(moduleIdResolver, moduleId); };\n            for (i = 0, len = dependencies.length; i < len; i++) {\n                dependencyId = dependencies[i];\n                if (dependencyId === 'require') {\n                    m.resolveDependency(dependencyId, this._createRequire(moduleIdResolver));\n                    continue;\n                }\n                else {\n                    if (dependencyId.indexOf('!') >= 0) {\n                        this._resolvePluginDependency(id, dependencyId);\n                    }\n                    else {\n                        this._resolveDependency(id, dependencyId, loadCallback);\n                    }\n                }\n            }\n            if (m.isComplete()) {\n                // This module was completed as soon as its been seen.\n                this._onModuleComplete(id, m.getExports());\n            }\n        };\n        return ModuleManager;\n    }());\n    AMDLoader.ModuleManager = ModuleManager;\n    /**\n     * Load `scriptSrc` only once (avoid multiple <script> tags)\n     */\n    var OnlyOnceScriptLoader = (function () {\n        function OnlyOnceScriptLoader(actualScriptLoader) {\n            this.actualScriptLoader = actualScriptLoader;\n            this.callbackMap = {};\n        }\n        OnlyOnceScriptLoader.prototype.setModuleManager = function (moduleManager) {\n            this.actualScriptLoader.setModuleManager(moduleManager);\n        };\n        OnlyOnceScriptLoader.prototype.load = function (scriptSrc, callback, errorback, recorder) {\n            var _this = this;\n            var scriptCallbacks = {\n                callback: callback,\n                errorback: errorback\n            };\n            if (this.callbackMap.hasOwnProperty(scriptSrc)) {\n                this.callbackMap[scriptSrc].push(scriptCallbacks);\n                return;\n            }\n            this.callbackMap[scriptSrc] = [scriptCallbacks];\n            this.actualScriptLoader.load(scriptSrc, function () { return _this.triggerCallback(scriptSrc); }, function (err) { return _this.triggerErrorback(scriptSrc, err); }, recorder);\n        };\n        OnlyOnceScriptLoader.prototype.triggerCallback = function (scriptSrc) {\n            var scriptCallbacks = this.callbackMap[scriptSrc];\n            delete this.callbackMap[scriptSrc];\n            for (var i = 0; i < scriptCallbacks.length; i++) {\n                scriptCallbacks[i].callback();\n            }\n        };\n        OnlyOnceScriptLoader.prototype.triggerErrorback = function (scriptSrc, err) {\n            var scriptCallbacks = this.callbackMap[scriptSrc];\n            delete this.callbackMap[scriptSrc];\n            for (var i = 0; i < scriptCallbacks.length; i++) {\n                scriptCallbacks[i].errorback(err);\n            }\n        };\n        return OnlyOnceScriptLoader;\n    }());\n    var BrowserScriptLoader = (function () {\n        function BrowserScriptLoader() {\n        }\n        /**\n         * Attach load / error listeners to a script element and remove them when either one has fired.\n         * Implemented for browssers supporting 'onreadystatechange' events, such as IE8 or IE9\n         */\n        BrowserScriptLoader.prototype.attachListenersV1 = function (script, callback, errorback) {\n            var unbind = function () {\n                script.detachEvent('onreadystatechange', loadEventListener);\n                if (script.addEventListener) {\n                    script.removeEventListener('error', errorEventListener);\n                }\n            };\n            var loadEventListener = function (e) {\n                if (script.readyState === 'loaded' || script.readyState === 'complete') {\n                    unbind();\n                    callback();\n                }\n            };\n            var errorEventListener = function (e) {\n                unbind();\n                errorback(e);\n            };\n            script.attachEvent('onreadystatechange', loadEventListener);\n            if (script.addEventListener) {\n                script.addEventListener('error', errorEventListener);\n            }\n        };\n        /**\n         * Attach load / error listeners to a script element and remove them when either one has fired.\n         * Implemented for browssers supporting HTML5 standard 'load' and 'error' events.\n         */\n        BrowserScriptLoader.prototype.attachListenersV2 = function (script, callback, errorback) {\n            var unbind = function () {\n                script.removeEventListener('load', loadEventListener);\n                script.removeEventListener('error', errorEventListener);\n            };\n            var loadEventListener = function (e) {\n                unbind();\n                callback();\n            };\n            var errorEventListener = function (e) {\n                unbind();\n                errorback(e);\n            };\n            script.addEventListener('load', loadEventListener);\n            script.addEventListener('error', errorEventListener);\n        };\n        BrowserScriptLoader.prototype.setModuleManager = function (moduleManager) {\n            /* Intentional empty */\n        };\n        BrowserScriptLoader.prototype.load = function (scriptSrc, callback, errorback) {\n            var script = document.createElement('script');\n            script.setAttribute('async', 'async');\n            script.setAttribute('type', 'text/javascript');\n            if (global.attachEvent) {\n                this.attachListenersV1(script, callback, errorback);\n            }\n            else {\n                this.attachListenersV2(script, callback, errorback);\n            }\n            script.setAttribute('src', scriptSrc);\n            document.getElementsByTagName('head')[0].appendChild(script);\n        };\n        return BrowserScriptLoader;\n    }());\n    var WorkerScriptLoader = (function () {\n        function WorkerScriptLoader() {\n            this.loadCalls = [];\n            this.loadTimeout = -1;\n        }\n        WorkerScriptLoader.prototype.setModuleManager = function (moduleManager) {\n            /* Intentional empty */\n        };\n        WorkerScriptLoader.prototype.load = function (scriptSrc, callback, errorback) {\n            var _this = this;\n            this.loadCalls.push({\n                scriptSrc: scriptSrc,\n                callback: callback,\n                errorback: errorback\n            });\n            if (navigator.userAgent.indexOf('Firefox') >= 0) {\n                // Firefox fails installing the timer every now and then :(\n                this._load();\n            }\n            else {\n                if (this.loadTimeout === -1) {\n                    this.loadTimeout = setTimeout(function () {\n                        _this.loadTimeout = -1;\n                        _this._load();\n                    }, 0);\n                }\n            }\n        };\n        WorkerScriptLoader.prototype._load = function () {\n            var loadCalls = this.loadCalls;\n            this.loadCalls = [];\n            var i, len = loadCalls.length, scripts = [];\n            for (i = 0; i < len; i++) {\n                scripts.push(loadCalls[i].scriptSrc);\n            }\n            var errorOccured = false;\n            try {\n                importScripts.apply(null, scripts);\n            }\n            catch (e) {\n                errorOccured = true;\n                for (i = 0; i < len; i++) {\n                    loadCalls[i].errorback(e);\n                }\n            }\n            if (!errorOccured) {\n                for (i = 0; i < len; i++) {\n                    loadCalls[i].callback();\n                }\n            }\n        };\n        return WorkerScriptLoader;\n    }());\n    var NodeScriptLoader = (function () {\n        function NodeScriptLoader() {\n            this._initialized = false;\n        }\n        NodeScriptLoader.prototype.setModuleManager = function (moduleManager) {\n            this._moduleManager = moduleManager;\n        };\n        NodeScriptLoader.prototype._init = function (nodeRequire) {\n            if (this._initialized) {\n                return;\n            }\n            this._initialized = true;\n            this._fs = nodeRequire('fs');\n            this._vm = nodeRequire('vm');\n            this._path = nodeRequire('path');\n            this._crypto = nodeRequire('crypto');\n        };\n        NodeScriptLoader.prototype.load = function (scriptSrc, callback, errorback, recorder) {\n            var _this = this;\n            var opts = this._moduleManager.getConfigurationOptions();\n            var checksum = opts.checksum || false;\n            var nodeRequire = (opts.nodeRequire || global.nodeRequire);\n            var nodeInstrumenter = (opts.nodeInstrumenter || function (c) { return c; });\n            this._init(nodeRequire);\n            if (/^node\\|/.test(scriptSrc)) {\n                var pieces = scriptSrc.split('|');\n                var moduleExports = null;\n                try {\n                    recorder.record(LoaderEventType.NodeBeginNativeRequire, pieces[2]);\n                    moduleExports = nodeRequire(pieces[2]);\n                }\n                catch (err) {\n                    recorder.record(LoaderEventType.NodeEndNativeRequire, pieces[2]);\n                    errorback(err);\n                    return;\n                }\n                recorder.record(LoaderEventType.NodeEndNativeRequire, pieces[2]);\n                this._moduleManager.enqueueDefineAnonymousModule([], function () { return moduleExports; });\n                callback();\n            }\n            else {\n                scriptSrc = Utilities.fileUriToFilePath(scriptSrc);\n                this._fs.readFile(scriptSrc, { encoding: 'utf8' }, function (err, data) {\n                    if (err) {\n                        errorback(err);\n                        return;\n                    }\n                    if (checksum) {\n                        var hash = _this._crypto\n                            .createHash('md5')\n                            .update(data, 'utf8')\n                            .digest('base64')\n                            .replace(/=+$/, '');\n                        _this._moduleManager.recordChecksum(scriptSrc, hash);\n                    }\n                    recorder.record(LoaderEventType.NodeBeginEvaluatingScript, scriptSrc);\n                    var vmScriptSrc = _this._path.normalize(scriptSrc);\n                    // Make the script src friendly towards electron\n                    if (isElectronRenderer) {\n                        var driveLetterMatch = vmScriptSrc.match(/^([a-z])\\:(.*)/i);\n                        if (driveLetterMatch) {\n                            vmScriptSrc = driveLetterMatch[1].toUpperCase() + ':' + driveLetterMatch[2];\n                        }\n                        vmScriptSrc = 'file:///' + vmScriptSrc.replace(/\\\\/g, '/');\n                    }\n                    var contents, prefix = '(function (require, define, __filename, __dirname) { ', suffix = '\\n});';\n                    if (data.charCodeAt(0) === NodeScriptLoader._BOM) {\n                        contents = prefix + data.substring(1) + suffix;\n                    }\n                    else {\n                        contents = prefix + data + suffix;\n                    }\n                    contents = nodeInstrumenter(contents, vmScriptSrc);\n                    var r;\n                    if (/^v0\\.12/.test(process.version)) {\n                        r = _this._vm.runInThisContext(contents, { filename: vmScriptSrc });\n                    }\n                    else {\n                        r = _this._vm.runInThisContext(contents, vmScriptSrc);\n                    }\n                    r.call(global, RequireFunc, DefineFunc, vmScriptSrc, _this._path.dirname(scriptSrc));\n                    recorder.record(LoaderEventType.NodeEndEvaluatingScript, scriptSrc);\n                    callback();\n                });\n            }\n        };\n        NodeScriptLoader._BOM = 0xFEFF;\n        return NodeScriptLoader;\n    }());\n    // ------------------------------------------------------------------------\n    // ------------------------------------------------------------------------\n    // ------------------------------------------------------------------------\n    // define\n    var DefineFunc = (function () {\n        function DefineFunc(id, dependencies, callback) {\n            if (typeof id !== 'string') {\n                callback = dependencies;\n                dependencies = id;\n                id = null;\n            }\n            if (typeof dependencies !== 'object' || !Utilities.isArray(dependencies)) {\n                callback = dependencies;\n                dependencies = null;\n            }\n            if (!dependencies) {\n                dependencies = ['require', 'exports', 'module'];\n            }\n            if (id) {\n                moduleManager.enqueueDefineModule(id, dependencies, callback);\n            }\n            else {\n                moduleManager.enqueueDefineAnonymousModule(dependencies, callback);\n            }\n        }\n        DefineFunc.amd = {\n            jQuery: true\n        };\n        return DefineFunc;\n    }());\n    var RequireFunc = (function () {\n        function RequireFunc() {\n            if (arguments.length === 1) {\n                if ((arguments[0] instanceof Object) && !Utilities.isArray(arguments[0])) {\n                    RequireFunc.config(arguments[0]);\n                    return;\n                }\n                if (typeof arguments[0] === 'string') {\n                    return moduleManager.synchronousRequire(arguments[0]);\n                }\n            }\n            if (arguments.length === 2 || arguments.length === 3) {\n                if (Utilities.isArray(arguments[0])) {\n                    moduleManager.defineModule(Utilities.generateAnonymousModule(), arguments[0], arguments[1], arguments[2], null);\n                    return;\n                }\n            }\n            throw new Error('Unrecognized require call');\n        }\n        RequireFunc.config = function (params, shouldOverwrite) {\n            if (shouldOverwrite === void 0) { shouldOverwrite = false; }\n            moduleManager.configure(params, shouldOverwrite);\n        };\n        RequireFunc.getConfig = function () {\n            return moduleManager.getConfigurationOptions();\n        };\n        /**\n         * Non standard extension to reset completely the loader state. This is used for running amdjs tests\n         */\n        RequireFunc.reset = function () {\n            moduleManager = new ModuleManager(scriptLoader);\n            scriptLoader.setModuleManager(moduleManager);\n        };\n        /**\n         * Non standard extension to fetch loader state for building purposes.\n         */\n        RequireFunc.getBuildInfo = function () {\n            return moduleManager.getBuildInfo();\n        };\n        /**\n         * Non standard extension to fetch loader events\n         */\n        RequireFunc.getStats = function () {\n            return moduleManager.getLoaderEvents();\n        };\n        /**\n         * Non standard extension to fetch checksums\n         */\n        RequireFunc.getChecksums = function () {\n            return moduleManager.getChecksums();\n        };\n        return RequireFunc;\n    }());\n    var global = _amdLoaderGlobal, hasPerformanceNow = (global.performance && typeof global.performance.now === 'function'), isWebWorker, isElectronRenderer, isElectronMain, isNode, scriptLoader, moduleManager, loaderAvailableTimestamp;\n    function initVars() {\n        isWebWorker = (typeof global.importScripts === 'function');\n        isElectronRenderer = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions['electron'] !== 'undefined' && process.type === 'renderer');\n        isElectronMain = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions['electron'] !== 'undefined' && process.type === 'browser');\n        isNode = (typeof module !== 'undefined' && !!module.exports);\n        if (isWebWorker) {\n            scriptLoader = new OnlyOnceScriptLoader(new WorkerScriptLoader());\n        }\n        else if (isNode) {\n            scriptLoader = new OnlyOnceScriptLoader(new NodeScriptLoader());\n        }\n        else {\n            scriptLoader = new OnlyOnceScriptLoader(new BrowserScriptLoader());\n        }\n        moduleManager = new ModuleManager(scriptLoader);\n        scriptLoader.setModuleManager(moduleManager);\n    }\n    function initConsole() {\n        // Define used console.* functions, in order to not fail in environments where they are not available\n        if (!isNode) {\n            if (!global.console) {\n                global.console = {};\n            }\n            if (!global.console.log) {\n                global.console.log = function () { };\n            }\n            if (!global.console.warn) {\n                global.console.warn = global.console.log;\n            }\n            if (!global.console.error) {\n                global.console.error = global.console.log;\n            }\n        }\n    }\n    function initMainScript() {\n        if (!isWebWorker && !isNode) {\n            window.onload = function () {\n                var i, len, main, scripts = document.getElementsByTagName('script');\n                // Look through all the scripts for the data-main attribute\n                for (i = 0, len = scripts.length; i < len; i++) {\n                    main = scripts[i].getAttribute('data-main');\n                    if (main) {\n                        break;\n                    }\n                }\n                // Load the main script\n                if (main) {\n                    moduleManager.defineModule(Utilities.generateAnonymousModule(), [main], null, null, null, new ModuleIdResolver(new Configuration(), ''));\n                }\n            };\n        }\n    }\n    function init() {\n        initVars();\n        initConsole();\n        initMainScript();\n        if (isNode) {\n            var _nodeRequire = (global.require || require);\n            var nodeRequire = function (what) {\n                moduleManager.getRecorder().record(LoaderEventType.NodeBeginNativeRequire, what);\n                var r = _nodeRequire(what);\n                moduleManager.getRecorder().record(LoaderEventType.NodeEndNativeRequire, what);\n                return r;\n            };\n            global.nodeRequire = nodeRequire;\n            RequireFunc.nodeRequire = nodeRequire;\n        }\n        if (isNode && !isElectronRenderer) {\n            module.exports = RequireFunc;\n            // These two defs are fore the local closure defined in node in the case that the loader is concatenated\n            define = function () {\n                DefineFunc.apply(null, arguments);\n            };\n            require = RequireFunc;\n        }\n        else {\n            // The global variable require can configure the loader\n            if (typeof global.require !== 'undefined' && typeof global.require !== 'function') {\n                RequireFunc.config(global.require);\n            }\n            if (!isElectronRenderer) {\n                global.define = define = DefineFunc;\n            }\n            else {\n                define = function () {\n                    DefineFunc.apply(null, arguments);\n                };\n            }\n            global.require = RequireFunc;\n            global.require.__$__nodeRequire = nodeRequire;\n        }\n    }\n    if (typeof global.define !== 'function' || !global.define.amd) {\n        init();\n        loaderAvailableTimestamp = getHighPerformanceTimestamp();\n    }\n})(AMDLoader || (AMDLoader = {}));\n"]}