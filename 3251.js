"use strict";(self.webpackChunkmy_application=self.webpackChunkmy_application||[]).push([[3251],{3251:(n,e,r)=>{r.r(e),r.d(e,{default:()=>a});const a=";;; make-matrix creates a matrix (a vector of vectors).\n(define make-matrix\n  (lambda (rows columns)\n    (do ((m (make-vector rows))\n         (i 0 (+ i 1)))\n        ((= i rows) m)\n        (vector-set! m i (make-vector columns)))))\n\n;;; matrix? checks to see if its argument is a matrix.\n;;; It isn't foolproof, but it's generally good enough.\n(define matrix?\n  (lambda (x)\n    (and (vector? x)\n         (> (vector-length x) 0)\n         (vector? (vector-ref x 0)))))\n\n;; matrix-rows returns the number of rows in a matrix.\n(define matrix-rows\n   (lambda (x)\n      (vector-length x)))\n\n;; matrix-columns returns the number of columns in a matrix.\n(define matrix-columns\n   (lambda (x)\n      (vector-length (vector-ref x 0))))\n\n;;; matrix-ref returns the jth element of the ith row.\n(define matrix-ref\n  (lambda (m i j)\n    (vector-ref (vector-ref m i) j)))\n\n;;; matrix-set! changes the jth element of the ith row.\n(define matrix-set!\n  (lambda (m i j x)\n    (vector-set! (vector-ref m i) j x)))\n\n;;; mul is the generic matrix/scalar multiplication procedure\n(define mul\n  (lambda (x y)\n    ;; mat-sca-mul multiplies a matrix by a scalar.\n    (define mat-sca-mul\n       (lambda (m x)\n          (let* ((nr (matrix-rows m))\n                 (nc (matrix-columns m))\n                 (r  (make-matrix nr nc)))\n             (do ((i 0 (+ i 1)))\n                 ((= i nr) r)\n                 (do ((j 0 (+ j 1)))\n                     ((= j nc))\n                     (matrix-set! r i j\n                        (* x (matrix-ref m i j))))))))\n\n    ;; mat-mat-mul multiplies one matrix by another, after verifying\n    ;; that the first matrix has as many columns as the second\n    ;; matrix has rows.\n    (define mat-mat-mul\n       (lambda (m1 m2)\n          (let* ((nr1 (matrix-rows m1))\n                 (nr2 (matrix-rows m2))\n                 (nc2 (matrix-columns m2))\n                 (r   (make-matrix nr1 nc2)))\n             (if (not (= (matrix-columns m1) nr2))\n                 (match-error m1 m2))\n             (do ((i 0 (+ i 1)))\n                 ((= i nr1) r)\n                 (do ((j 0 (+ j 1)))\n                     ((= j nc2))\n                     (do ((k 0 (+ k 1))\n                          (a 0\n                             (+ a\n                                (* (matrix-ref m1 i k)\n                                   (matrix-ref m2 k j)))))\n                         ((= k nr2)\n                          (matrix-set! r i j a))))))))\n\n   ;; type-error is called to complain when mul receives an invalid\n   ;; type of argument.\n    (define type-error\n       (lambda (what)\n          (error 'mul\n             \"~s is not a number or matrix\"\n             what)))\n\n    ;; match-error is called to complain when mul receives a pair of\n    ;; incompatible arguments.\n    (define match-error\n       (lambda (what1 what2)\n          (error 'mul\n             \"~s and ~s are incompatible operands\"\n             what1\n             what2)))\n\n    ;; body of mul; dispatch based on input types\n    (cond\n      ((number? x)\n       (cond\n         ((number? y) (* x y))\n         ((matrix? y) (mat-sca-mul y x))\n         (else (type-error y))))\n      ((matrix? x)\n       (cond\n         ((number? y) (mat-sca-mul x y))\n         ((matrix? y) (mat-mat-mul x y))\n         (else (type-error y))))\n      (else (type-error x)))))"}}]);
//# sourceMappingURL=3251.js.map