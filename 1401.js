"use strict";(self.webpackChunkmy_application=self.webpackChunkmy_application||[]).push([[1401],{1401:(n,e,t)=>{t.r(e),t.d(e,{default:()=>r});const r='// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full\n// license information.\n\n/*\n *\tCOMMAND LINE: -Ox -Gz -YX -UPROTOTYPES_REQUIRED\n */\n\n#pragma warning(disable : 4532)\n#pragma warning(disable : 4702)\n\n#if defined(_WIN32)\n\n#if defined(_M_SH)\n#define WIN_CE\n#endif\n\n#if defined(_M_AMD64)\n#define NEST_IN_FINALLY /* allow when __try nested in __finally OK */\n#endif\n\n#define NTSTATUS LONG\n#define EXCEPTION_NESTED_CALL 0x10\n#define RtlRaiseStatus(x) RaiseException((x), 0, 0, NULL)\n#define RtlRaiseException(x)                                                   \\\n  RaiseException((x)->ExceptionCode, (x)->ExceptionFlags,                      \\\n                 (x)->NumberParameters, (x)->ExceptionInformation)\n#define IN\n#define OUT\n#if !(defined(_M_IA64) || defined(_M_ALPHA) || defined(_M_PPC) ||              \\\n      defined(_M_AMD64) || defined(_M_ARM) || defined(_M_ARM64))\n#define i386 1\n#endif\n#define try __try\n#define except __except\n#define finally __finally\n#define leave __leave\n\n#endif\n\n#define WIN32_LEAN_AND_MEAN\n\n#include "stdio.h"\n#if defined(_M_IA64) || defined(_M_ALPHA) || defined(_M_PPC) ||                \\\n    defined(_M_AMD64) || defined(_M_ARM) || defined(_M_ARM64)\n#include "setjmpex.h"\n#else\n#include "setjmp.h"\n#endif\n#include "float.h"\n#include "windows.h"\n#include "math.h"\n\n#if !defined(STATUS_SUCCESS)\n#define STATUS_SUCCESS 0\n#endif\n#if !defined(STATUS_UNSUCCESSFUL)\n#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)\n#endif\n\n//\n// Define switch constants.\n//\n\n#define BLUE 0\n#define RED 1\n\n//\n// Define function prototypes.\n//\n\nVOID addtwo(IN LONG First, IN LONG Second, IN PLONG Place);\n\nVOID bar1(IN NTSTATUS Status, IN PLONG Counter);\n\nVOID bar2(IN PLONG BlackHole, IN PLONG BadAddress, IN PLONG Counter);\n\nVOID dojump(IN jmp_buf JumpBuffer, IN PLONG Counter);\n\nLONG Echo(IN LONG Value);\n\n#if !defined(WIN_CE) // return through finally not allowed on WinCE\nVOID eret(IN NTSTATUS Status, IN PLONG Counter);\n#endif\n\nVOID except1(IN PLONG Counter);\n\nULONG\nexcept2(IN PEXCEPTION_POINTERS ExceptionPointers, IN PLONG Counter);\n\nULONG\nexcept3(IN PEXCEPTION_POINTERS ExceptionPointers, IN PLONG Counter);\n\nVOID foo1(IN NTSTATUS Status);\n\nVOID foo2(IN PLONG BlackHole, IN PLONG BadAddress);\n\n#if !defined(WIN_CE) // return from finally not allowed on WinCE\nVOID fret(IN PLONG Counter);\n#endif\n\nBOOLEAN\nTkm(VOID);\n\nVOID Test61Part2(IN OUT PULONG Counter);\n\ndouble SquareDouble(IN double op);\n\nDECLSPEC_NOINLINE\nULONG\nPgFilter(VOID)\n\n{\n\n  printf("filter entered...");\n  return EXCEPTION_EXECUTE_HANDLER;\n}\n\n#pragma warning(push)\n#pragma warning(disable : 4532)\n\nVOID PgTest69(IN PLONG State, IN PLONG Fault)\n\n{\n\n  try {\n    try {\n      *Fault += 1;\n    }\n    finally {\n      if (AbnormalTermination()) {\n        if (*State == 1) {\n          *State += 1;\n\n        } else {\n          *Fault += 1;\n        }\n      }\n    }\n  }\n  except(((*State += 1) == 1) ? PgFilter() : EXCEPTION_CONTINUE_SEARCH) {\n    if (*State != 2) {\n      *Fault += 1;\n    }\n  }\n\n  return;\n}\n\nVOID PgTest70(IN PLONG State, IN PLONG Fault)\n\n{\n\n  try {\n    try {\n      *Fault += 1;\n    }\n    finally {\n      if (AbnormalTermination()) {\n        if (*State == 2) {\n          PgFilter();\n          return;\n\n        } else {\n          *Fault += 1;\n        }\n      }\n    }\n  }\n  except(((*State += 2) == 2) ? EXCEPTION_EXECUTE_HANDLER\n                              : EXCEPTION_CONTINUE_SEARCH) {\n    *Fault += 1;\n  }\n\n  return;\n}\n\nVOID PgTest71(IN PLONG State, IN PLONG Fault)\n\n{\n\n  try {\n    try {\n      try {\n        *Fault += 1;\n      }\n      finally {\n        if (AbnormalTermination()) {\n          if (*State == 3) {\n            *State += 3;\n            return;\n\n          } else {\n            *Fault += 1;\n          }\n        }\n      }\n    }\n    finally {\n      if (AbnormalTermination()) {\n        if (*State == 6) {\n          *State += 3;\n\n        } else {\n          *Fault += 1;\n        }\n      }\n    }\n  }\n  except(((*State += 3) == 3) ? PgFilter() : EXCEPTION_CONTINUE_SEARCH) {\n    *Fault += 1;\n  }\n\n  return;\n}\n\nVOID PgTest72(IN PLONG State, IN PLONG Fault)\n\n{\n\n  try {\n    try {\n      try {\n        *Fault += 1;\n      }\n      finally {\n        if (AbnormalTermination()) {\n          if (*State == 4) {\n            *State += 4;\n            return;\n\n          } else {\n            *Fault += 1;\n          }\n        }\n      }\n    }\n    finally {\n      if (AbnormalTermination()) {\n        if (*State == 8) {\n          *State += 4;\n          PgFilter();\n\n        } else {\n          *Fault += 1;\n        }\n      }\n    }\n  }\n  except(((*State += 4) == 4) ? EXCEPTION_EXECUTE_HANDLER\n                              : EXCEPTION_CONTINUE_SEARCH) {\n    *Fault += 1;\n  }\n\n  return;\n}\n\nVOID PgTest73(IN PLONG State, IN PLONG Fault)\n\n{\n\n  try {\n    try {\n      try {\n        *Fault += 1;\n      }\n      finally {\n        if (AbnormalTermination()) {\n          if (*State == 5) {\n            *State += 5;\n\n          } else {\n            *Fault += 1;\n          }\n        }\n      }\n    }\n    finally {\n      if (AbnormalTermination()) {\n        if (*State == 10) {\n          *State += 5;\n          return;\n\n        } else {\n          *Fault += 1;\n        }\n      }\n    }\n  }\n  except(((*State += 5) == 5) ? PgFilter() : EXCEPTION_CONTINUE_SEARCH) {\n    *Fault += 1;\n  }\n\n  return;\n}\n\nVOID PgTest74(IN PLONG State, IN PLONG Fault)\n\n{\n\n  try {\n    try {\n      try {\n        *Fault += 1;\n      }\n      finally {\n        if (AbnormalTermination()) {\n          if (*State == 6) {\n            *State += 6;\n\n          } else {\n            *Fault += 1;\n          }\n        }\n      }\n    }\n    finally {\n      if (AbnormalTermination()) {\n        if (*State == 12) {\n          *State += 6;\n          PgFilter();\n          return;\n\n        } else {\n          *Fault += 1;\n        }\n      }\n    }\n  }\n  except(((*State += 6) == 6) ? EXCEPTION_EXECUTE_HANDLER\n                              : EXCEPTION_CONTINUE_SEARCH) {\n    *Fault += 1;\n  }\n\n  return;\n}\n\nVOID PgTest75(IN PLONG State, IN PLONG Fault)\n\n{\n\n  try {\n    try {\n      try {\n        try {\n          *Fault += 1;\n        }\n        finally {\n          if (AbnormalTermination()) {\n            if (*State == 7) {\n              *State += 7;\n              *Fault += 1;\n\n            } else {\n              *State += 10;\n            }\n          }\n        }\n      }\n      except(((*State += 7) == 7) ? EXCEPTION_EXECUTE_HANDLER\n                                  : EXCEPTION_CONTINUE_SEARCH) {\n        *Fault += 1;\n      }\n    }\n    finally {\n      if (AbnormalTermination()) {\n        if (*State == 28) {\n          *State += 7;\n          return;\n\n        } else {\n          *Fault += 1;\n        }\n      }\n    }\n  }\n  except(((*State += 7) == 28) ? PgFilter() : EXCEPTION_CONTINUE_SEARCH) {\n    *Fault += 1;\n  }\n\n  return;\n}\n\nVOID PgTest76(IN PLONG State, IN PLONG Fault)\n\n{\n\n  try {\n    try {\n      try {\n        try {\n          *Fault += 1;\n        }\n        finally {\n          if (AbnormalTermination()) {\n            if (*State == 8) {\n              *State += 8;\n              *Fault += 1;\n\n            } else {\n              *State += 10;\n            }\n          }\n        }\n      }\n      except(((*State += 8) == 8) ? EXCEPTION_EXECUTE_HANDLER\n                                  : EXCEPTION_CONTINUE_SEARCH) {\n        *Fault += 1;\n      }\n    }\n    finally {\n      if (AbnormalTermination()) {\n        if (*State == 32) {\n          *State += 8;\n          PgFilter();\n          return;\n\n        } else {\n          *Fault += 1;\n        }\n      }\n    }\n  }\n  except(((*State += 8) == 32) ? EXCEPTION_EXECUTE_HANDLER\n                               : EXCEPTION_CONTINUE_SEARCH) {\n    *Fault += 1;\n  }\n\n  return;\n}\n\nVOID PgTest77(IN PLONG State, IN PLONG Fault)\n\n{\n\n  try {\n    try {\n      try {\n        try {\n          *Fault += 1;\n        }\n        finally {\n          if (AbnormalTermination()) {\n            if (*State == 9) {\n              *State += 9;\n              *Fault += 1;\n\n            } else {\n              *State += 10;\n            }\n          }\n        }\n      }\n      except(((*State += 9) == 9) ? PgFilter() : EXCEPTION_CONTINUE_SEARCH) {\n        *Fault += 1;\n      }\n    }\n    finally {\n      if (AbnormalTermination()) {\n        if (*State == 36) {\n          *State += 9;\n          return;\n\n        } else {\n          *Fault += 1;\n        }\n      }\n    }\n  }\n  except(((*State += 9) == 36) ? EXCEPTION_EXECUTE_HANDLER\n                               : EXCEPTION_CONTINUE_SEARCH) {\n    *Fault += 1;\n  }\n\n  return;\n}\n\nVOID PgTest78(IN PLONG State, IN PLONG Fault)\n\n{\n\n  try {\n    try {\n      try {\n        try {\n          *Fault += 1;\n        }\n        finally {\n          if (AbnormalTermination()) {\n            if (*State == 10) {\n              *State += 10;\n              PgFilter();\n              *Fault += 1;\n\n            } else {\n              *State += 10;\n            }\n          }\n        }\n      }\n      except(((*State += 10) == 10) ? EXCEPTION_EXECUTE_HANDLER\n                                    : EXCEPTION_CONTINUE_SEARCH) {\n        *Fault += 1;\n      }\n    }\n    finally {\n      if (AbnormalTermination()) {\n        if (*State == 40) {\n          *State += 10;\n          return;\n\n        } else {\n          *Fault += 1;\n        }\n      }\n    }\n  }\n  except(((*State += 10) == 40) ? EXCEPTION_EXECUTE_HANDLER\n                                : EXCEPTION_CONTINUE_SEARCH) {\n    *Fault += 1;\n  }\n\n  return;\n}\n\n#pragma warning(pop)\n\nVOID Test79(PLONG Counter, PLONG Fault)\n\n{\n\n  try {\n    try {\n      try {\n        *Fault += 1;\n      }\n      finally {\n        printf("finally 1...");\n        *Fault += 1;\n      }\n    }\n    finally { printf("finally 2..."); }\n  }\n  except(*Counter += 1, printf("filter 1..."), EXCEPTION_CONTINUE_SEARCH) {}\n\n  return;\n}\n\nULONG G;\n\nULONG\nTest80(VOID)\n\n{\n\n  G = 1;\n  try {\n    while (G) {\n      try {\n        if (G == 10) {\n          return 1;\n        }\n\n        if (G == 1) {\n          continue;\n        }\n      }\n      finally { G = 0; }\n    }\n  }\n  finally { G = 10; }\n\n  return 0;\n}\n\nvoid Test81(int *pCounter) {\n  volatile char *AvPtr = NULL;\n\n  __try {\n    __try { *AvPtr = \'\\0\'; }\n    __except(EXCEPTION_EXECUTE_HANDLER) { __leave; }\n  }\n  __finally {\n    printf("in finally ");\n    *pCounter += 1;\n  }\n  return;\n}\n\nDECLSPEC_NOINLINE\nVOID Test82Foo(VOID)\n\n{\n  *(volatile int *)0 = 0;\n}\n\nVOID Test82(__inout PLONG Counter)\n\n{\n\n  int retval = 1;\n\n  __try {\n    __try { Test82Foo(); }\n    __finally {\n      switch (*Counter) {\n      case 0:\n        printf("something failed!\\n");\n        retval = 6;\n        break;\n\n      case 1:\n        retval = 0;\n        break;\n\n      case 2:\n        printf("how did you get here?\\n");\n        retval = 2;\n        break;\n\n      case 3:\n        printf("what?!?\\n");\n        retval = 3;\n        break;\n\n      case 4:\n        printf("not correct\\n");\n        retval = 4;\n        break;\n\n      case 5:\n        printf("error!\\n");\n        retval = 5;\n        break;\n      }\n    }\n  }\n  __except(1){}\n\n  *Counter = retval;\n  return;\n}\n\nLONG Test83(VOID)\n\n{\n\n  G = 1;\n  try {\n    try {\n      while (G) {\n        try {\n          if (G == 10) {\n            return 1;\n          }\n\n          if (G == 1) {\n            continue;\n          }\n        }\n        finally { G = 0; }\n      }\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) { leave; }\n  }\n  finally { G = 10; }\n\n  return 0;\n}\n\nDECLSPEC_NOINLINE\nVOID Test84(_Inout_ PLONG Counter)\n\n{\n  volatile int *Fault = 0;\n\n  try {\n    try {\n      *Fault += 1;\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) {\n      try {\n        return;\n      }\n      finally { *Counter += 1; }\n    }\n  }\n  finally {\n\n    if (AbnormalTermination()) {\n      *Counter += 1;\n    }\n  }\n\n  return;\n}\n\nDECLSPEC_NOINLINE\nLONG Test85(_Inout_ PLONG Counter)\n\n{\n  volatile int *Fault = 0;\n\n  G = 1;\n  try {\n    try {\n      try {\n        while (G) {\n          try {\n            try {\n              if (G == 10) {\n                return 1;\n              }\n              try {\n                *Counter += 1;\n              }\n              except(EXCEPTION_EXECUTE_HANDLER) {}\n\n              if (G == 1) {\n                continue;\n              }\n            }\n            finally {\n              G = 0;\n              *Counter += 1;\n              *Fault += 1;\n            }\n          }\n          except(EXCEPTION_EXECUTE_HANDLER) {\n            *Counter += 1;\n            leave;\n          }\n        }\n      }\n      finally {\n        G = 10;\n        *Counter += 1;\n        *Fault += 1;\n      }\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) { *Counter += 1; }\n    *Counter += 1;\n  }\n  finally { *Counter += 1; }\n  return 1;\n}\n\nDECLSPEC_NOINLINE\nVOID Test86(_Inout_ PLONG Counter)\n\n{\n  volatile int *Fault = 0;\n\n  try {\n    try {\n      try {\n        try {\n          try {\n            try {\n              *Fault += 1;\n            }\n            except(printf("Filter1 %d..", *Counter),\n                   EXCEPTION_EXECUTE_HANDLER) {\n              try {\n                printf("Handler1 %d..", *Counter);\n                return;\n              }\n              finally {\n                printf("Finally1 %d..", *Counter);\n                *Counter += 1;\n              }\n            }\n          }\n          finally {\n            printf("Finally2 %d..", *Counter);\n            *Counter += 1;\n          }\n        }\n        except(EXCEPTION_EXECUTE_HANDLER) { leave; }\n      }\n      finally { *Counter += 1; }\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) { leave; }\n  }\n  finally { *Counter += 1; }\n\n  return;\n}\n\nVOID Test87(_Inout_ PLONG Counter)\n\n/*++\n\nRoutine Description:\n\n    This function verifies the behavior of nested exception dispatching.\n\nArguments:\n\n    Counter - Supplies a pointer to the state counter.\n\nReturn Value:\n    None.\n\n--*/\n\n{\n  volatile int *Fault = 0;\n\n//\n// N.B.  Disabled on x86 due to failing test case with handling of returns\n//       in nested termination handlers on x86.\n//\n//       Disabled on ARM due to failing test case with handling of abutting\n//       termination handlers within an except handler.\n//\n//       Disabled on AMD64 due to failing test case with handling of\n//       abutting termination handlers within an except handler when a\n//       non-local goto is involved.\n//\n\n#if !defined(_X86_)\n  try {\n    try {\n      try {\n        try {\n          try {\n            *Fault += 1;\n\n            try {\n            }\n            finally {\n              if (AbnormalTermination()) {\n                *Fault += 1;\n              }\n            }\n          }\n          finally {\n\n            if (AbnormalTermination()) {\n              if ((*Counter += 13) == 26) {\n                return;\n\n              } else {\n                *Fault += 1;\n              }\n            }\n          }\n        }\n        finally {\n          if (AbnormalTermination()) {\n            *Counter += 13;\n            *Fault += 1;\n          }\n        }\n      }\n      except(((*Counter += 13) == 13) ? EXCEPTION_EXECUTE_HANDLER\n                                      : EXCEPTION_CONTINUE_SEARCH) {\n        *Fault += 1;\n      }\n    }\n    except(((*Counter += 13) == 65) ? EXCEPTION_EXECUTE_HANDLER\n                                    : EXCEPTION_CONTINUE_SEARCH) {\n      try {\n        *Counter += 13;\n        return;\n      }\n      finally {\n        if (AbnormalTermination()) {\n          *Counter += 13;\n          goto Finish;\n        }\n      }\n    }\n  }\n  finally {\n\n    if (AbnormalTermination()) {\n      if ((*Counter += 13) == 104) {\n        goto Finish;\n      }\n    }\n  }\n\nFinish:\n#else\n  *Counter = 104;\n#endif\n\n  return;\n}\n\nVOID Test88(_Inout_ PLONG Counter)\n\n{\n  volatile int *Fault = 0;\n\n  try {\n    try {\n      try {\n        try {\n          try {\n            try {\n              try {\n                try {\n                  *Fault += 1;\n                }\n                except(((*Counter += 1) == 1) ? *Fault\n                                              : EXCEPTION_CONTINUE_SEARCH) {}\n              }\n              except(*Counter += 1, EXCEPTION_EXECUTE_HANDLER) { *Fault += 2; }\n            }\n            except(*Counter += 1, EXCEPTION_CONTINUE_SEARCH) { leave; }\n          }\n          except(*Counter += 1, EXCEPTION_CONTINUE_SEARCH) { leave; }\n        }\n        except(EXCEPTION_EXECUTE_HANDLER) {}\n      }\n      except(EXCEPTION_EXECUTE_HANDLER) {}\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) { leave; }\n  }\n  finally { *Counter += 1; }\n}\n\nint main(int argc, char *argv[])\n\n{\n\n  PLONG BadAddress;\n  PCHAR BadByte;\n  PLONG BlackHole;\n  ULONG Index1;\n  ULONG Index2 = RED;\n  jmp_buf JumpBuffer;\n  LONG Counter;\n  EXCEPTION_RECORD ExceptionRecord;\n  double doubleresult;\n\n  //\n  // Announce start of exception test.\n  //\n\n  printf("Start of exception test\\n");\n\n  //\n  // Initialize exception record.\n  //\n\n  ExceptionRecord.ExceptionCode = STATUS_INTEGER_OVERFLOW;\n  ExceptionRecord.ExceptionFlags = 0;\n  ExceptionRecord.ExceptionRecord = NULL;\n  ExceptionRecord.NumberParameters = 0;\n\n  //\n  // Initialize pointers.\n  //\n\n  BadAddress = (PLONG)NULL;\n  BadByte = (PCHAR)NULL;\n  BadByte += 1;\n  BlackHole = &Counter;\n\n  //\n  // Simply try statement with a finally clause that is entered sequentially.\n  //\n\n  printf("    test1...");\n  Counter = 0;\n  try {\n    Counter += 1;\n  }\n  finally {\n    if (abnormal_termination() == FALSE) {\n      Counter += 1;\n    }\n  }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Simple try statement with an exception clause that is never executed\n  // because there is no exception raised in the try clause.\n  //\n\n  printf("    test2...");\n  Counter = 0;\n  try {\n    Counter += 1;\n  }\n  except(Counter) { Counter += 1; }\n\n  if (Counter != 1) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Simple try statement with an exception handler that is never executed\n  // because the exception expression continues execution.\n  //\n\n  printf("    test3...");\n  Counter = 0;\n  try {\n    Counter -= 1;\n    RtlRaiseException(&ExceptionRecord);\n  }\n  except(Counter) { Counter -= 1; }\n\n  if (Counter != -1) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Simple try statement with an exception clause that is always executed.\n  //\n\n  printf("    test4...");\n  Counter = 0;\n  try {\n    Counter += 1;\n    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n  }\n  except(Counter) { Counter += 1; }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Simple try statement with an exception clause that is always executed.\n  //\n\n  printf("    test5...");\n  Counter = 0;\n  try {\n    Counter += 1;\n    *BlackHole += *BadAddress;\n  }\n  except(Counter) { Counter += 1; }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Simply try statement with a finally clause that is entered as the\n  // result of an exception.\n  //\n\n  printf("    test6...");\n  Counter = 0;\n  try {\n    try {\n      Counter += 1;\n      RtlRaiseException(&ExceptionRecord);\n    }\n    finally {\n      if (abnormal_termination() != FALSE) {\n        Counter += 1;\n      }\n    }\n  }\n  except(Counter) {\n    if (Counter == 2) {\n      Counter += 1;\n    }\n  }\n\n  if (Counter != 3) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Simply try statement with a finally clause that is entered as the\n  // result of an exception.\n  //\n\n  printf("    test7...");\n  Counter = 0;\n  try {\n    try {\n      Counter += 1;\n      *BlackHole += *BadAddress;\n    }\n    finally {\n      if (abnormal_termination() != FALSE) {\n        Counter += 1;\n      }\n    }\n  }\n  except(Counter) {\n    if (Counter == 2) {\n      Counter += 1;\n    }\n  }\n\n  if (Counter != 3) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Simple try that calls a function which raises an exception.\n  //\n\n  printf("    test8...");\n  Counter = 0;\n  try {\n    Counter += 1;\n    foo1(STATUS_ACCESS_VIOLATION);\n  }\n  except((GetExceptionCode() == STATUS_ACCESS_VIOLATION)\n             ? EXCEPTION_EXECUTE_HANDLER\n             : EXCEPTION_CONTINUE_SEARCH) {\n    Counter += 1;\n  }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Simple try that calls a function which raises an exception.\n  //\n\n  printf("    test9...");\n  Counter = 0;\n  try {\n    Counter += 1;\n    foo2(BlackHole, BadAddress);\n  }\n  except((GetExceptionCode() == STATUS_ACCESS_VIOLATION)\n             ? EXCEPTION_EXECUTE_HANDLER\n             : EXCEPTION_CONTINUE_SEARCH) {\n    Counter += 1;\n  }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Simple try that calls a function which calls a function that\n  // raises an exception. The first function has a finally clause\n  // that must be executed for this test to work.\n  //\n\n  printf("    test10...");\n  Counter = 0;\n  try {\n    bar1(STATUS_ACCESS_VIOLATION, &Counter);\n  }\n  except((GetExceptionCode() == STATUS_ACCESS_VIOLATION)\n             ? EXCEPTION_EXECUTE_HANDLER\n             : EXCEPTION_CONTINUE_SEARCH) {\n    Counter -= 1;\n  }\n\n  if (Counter != 98) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Simple try that calls a function which calls a function that\n  // raises an exception. The first function has a finally clause\n  // that must be executed for this test to work.\n  //\n\n  printf("    test11...");\n  Counter = 0;\n  try {\n    bar2(BlackHole, BadAddress, &Counter);\n  }\n  except((GetExceptionCode() == STATUS_ACCESS_VIOLATION)\n             ? EXCEPTION_EXECUTE_HANDLER\n             : EXCEPTION_CONTINUE_SEARCH) {\n    Counter -= 1;\n  }\n\n  if (Counter != 98) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A try within an except\n  //\n\n  printf("    test12...");\n  Counter = 0;\n  try {\n    foo1(STATUS_ACCESS_VIOLATION);\n  }\n  except((GetExceptionCode() == STATUS_ACCESS_VIOLATION)\n             ? EXCEPTION_EXECUTE_HANDLER\n             : EXCEPTION_CONTINUE_SEARCH) {\n    Counter += 1;\n    try {\n      foo1(STATUS_SUCCESS);\n    }\n    except((GetExceptionCode() == STATUS_SUCCESS) ? EXCEPTION_EXECUTE_HANDLER\n                                                  : EXCEPTION_CONTINUE_SEARCH) {\n      if (Counter != 1) {\n        printf("failed, count = %d\\n", Counter);\n\n      } else {\n        printf("succeeded...");\n      }\n\n      Counter += 1;\n    }\n  }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A try within an except\n  //\n\n  printf("    test13...");\n  Counter = 0;\n  try {\n    foo2(BlackHole, BadAddress);\n  }\n  except((GetExceptionCode() == STATUS_ACCESS_VIOLATION)\n             ? EXCEPTION_EXECUTE_HANDLER\n             : EXCEPTION_CONTINUE_SEARCH) {\n    Counter += 1;\n    try {\n      foo1(STATUS_SUCCESS);\n    }\n    except((GetExceptionCode() == STATUS_SUCCESS) ? EXCEPTION_EXECUTE_HANDLER\n                                                  : EXCEPTION_CONTINUE_SEARCH) {\n      if (Counter != 1) {\n        printf("failed, count = %d\\n", Counter);\n\n      } else {\n        printf("succeeded...");\n      }\n\n      Counter += 1;\n    }\n  }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n#if !defined(WIN_CE) // gotos from except/finally not allowed on WinCE\n  //\n  // A goto from an exception clause that needs to pass\n  // through a finally\n  //\n\n  printf("    test14...");\n  Counter = 0;\n  try {\n    try {\n      foo1(STATUS_ACCESS_VIOLATION);\n    }\n    except((GetExceptionCode() == STATUS_ACCESS_VIOLATION)\n               ? EXCEPTION_EXECUTE_HANDLER\n               : EXCEPTION_CONTINUE_SEARCH) {\n      Counter += 1;\n      goto t9;\n    }\n  }\n  finally { Counter += 1; }\n\nt9:\n  ;\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A goto from an finally clause that needs to pass\n  // through a finally\n  //\n\n  printf("    test15...");\n  Counter = 0;\n  try {\n    try {\n      Counter += 1;\n    }\n    finally {\n      Counter += 1;\n      goto t10;\n    }\n  }\n  finally { Counter += 1; }\n\nt10:\n  ;\n  if (Counter != 3) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A goto from an exception clause that needs to pass\n  // through a finally into the outer finally clause.\n  //\n\n  printf("    test16...");\n  Counter = 0;\n  try {\n    try {\n      try {\n        Counter += 1;\n        foo1(STATUS_INTEGER_OVERFLOW);\n      }\n      except(EXCEPTION_EXECUTE_HANDLER) {\n        Counter += 1;\n        goto t11;\n      }\n    }\n    finally { Counter += 1; }\n  t11:\n    ;\n  }\n  finally { Counter += 1; }\n\n  if (Counter != 4) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A goto from an finally clause that needs to pass\n  // through a finally into the outer finally clause.\n  //\n\n  printf("    test17...");\n  Counter = 0;\n  try {\n    try {\n      Counter += 1;\n    }\n    finally {\n      Counter += 1;\n      goto t12;\n    }\n  t12:\n    ;\n  }\n  finally { Counter += 1; }\n\n  if (Counter != 3) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A return from an except clause\n  //\n\n  printf("    test18...");\n  Counter = 0;\n  try {\n    Counter += 1;\n    eret(STATUS_ACCESS_VIOLATION, &Counter);\n  }\n  finally { Counter += 1; }\n\n  if (Counter != 4) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A return from a finally clause\n  //\n\n  printf("    test19...");\n  Counter = 0;\n  try {\n    Counter += 1;\n    fret(&Counter);\n  }\n  finally { Counter += 1; }\n\n  if (Counter != 5) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n#endif\n\n  //\n  // A simple set jump followed by a long jump.\n  //\n\n  printf("    test20...");\n  Counter = 0;\n  if (setjmp(JumpBuffer) == 0) {\n    Counter += 1;\n    longjmp(JumpBuffer, 1);\n\n  } else {\n    Counter += 1;\n  }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A set jump followed by a long jump out of a finally clause that is\n  // sequentially executed.\n  //\n\n  printf("    test21...");\n  Counter = 0;\n  if (setjmp(JumpBuffer) == 0) {\n    try {\n      Counter += 1;\n    }\n    finally {\n      Counter += 1;\n      longjmp(JumpBuffer, 1);\n    }\n\n  } else {\n    Counter += 1;\n  }\n\n  if (Counter != 3) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A set jump within a try clause followed by a long jump out of a\n  // finally clause that is sequentially executed.\n  //\n\n  printf("    test22...");\n  Counter = 0;\n  try {\n    if (setjmp(JumpBuffer) == 0) {\n      Counter += 1;\n\n    } else {\n      Counter += 1;\n    }\n  }\n  finally {\n    Counter += 1;\n    if (Counter == 2) {\n      Counter += 1;\n      longjmp(JumpBuffer, 1);\n    }\n  }\n\n  if (Counter != 5) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A set jump followed by a try/except, followed by a try/finally where\n  // the try body of the try/finally raises an exception that is handled\n  // by the try/excecpt which causes the try/finally to do a long jump out\n  // of a finally clause. This will create a collided unwind.\n  //\n\n  printf("    test23...");\n  Counter = 0;\n  if (setjmp(JumpBuffer) == 0) {\n    try {\n      try {\n        Counter += 1;\n        RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n      }\n      finally {\n        Counter += 1;\n        longjmp(JumpBuffer, 1);\n      }\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 1; }\n\n  } else {\n    Counter += 1;\n  }\n\n  if (Counter != 3) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A set jump followed by a try/except, followed by a several nested\n  // try/finally\'s where the inner try body of the try/finally raises an\n  // exception that is handled by the try/except which causes the\n  // try/finally to do a long jump out of a finally clause. This will\n  // create a collided unwind.\n  //\n\n  printf("    test24...");\n  Counter = 0;\n  if (setjmp(JumpBuffer) == 0) {\n    try {\n      try {\n        try {\n          try {\n            Counter += 1;\n            RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n          }\n          finally { Counter += 1; }\n        }\n        finally {\n          Counter += 1;\n          longjmp(JumpBuffer, 1);\n        }\n      }\n      finally { Counter += 1; }\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 1; }\n\n  } else {\n    Counter += 1;\n  }\n\n  if (Counter != 5) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A set jump followed by a try/except, followed by a try/finally which\n  // calls a subroutine which contains a try finally that raises an\n  // exception that is handled to the try/except.\n  //\n\n  printf("    test25...");\n  Counter = 0;\n  if (setjmp(JumpBuffer) == 0) {\n    try {\n      try {\n        try {\n          Counter += 1;\n          dojump(JumpBuffer, &Counter);\n        }\n        finally { Counter += 1; }\n      }\n      finally { Counter += 1; }\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 1; }\n\n  } else {\n    Counter += 1;\n  }\n\n  if (Counter != 7) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A set jump followed by a try/except, followed by a try/finally which\n  // calls a subroutine which contains a try finally that raises an\n  // exception that is handled to the try/except.\n  //\n\n  printf("    test26...");\n  Counter = 0;\n  if (setjmp(JumpBuffer) == 0) {\n    try {\n      try {\n        try {\n          try {\n            Counter += 1;\n            dojump(JumpBuffer, &Counter);\n          }\n          finally { Counter += 1; }\n        }\n        finally {\n          Counter += 1;\n          longjmp(JumpBuffer, 1);\n        }\n      }\n      finally { Counter += 1; }\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 1; }\n\n  } else {\n    Counter += 1;\n  }\n\n  if (Counter != 8) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Test nested exceptions.\n  //\n\n  printf("    test27...");\n  Counter = 0;\n  try {\n    try {\n      Counter += 1;\n      except1(&Counter);\n    }\n    except(except2(GetExceptionInformation(), &Counter)) { Counter += 2; }\n  }\n  except(EXCEPTION_EXECUTE_HANDLER) { Counter += 3; }\n\n  if (Counter != 55) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Simple try that causes an integer overflow exception.\n  //\n\n  printf("    test28...");\n  Counter = 0;\n  try {\n    Counter += 1;\n    addtwo(0x7fff0000, 0x10000, &Counter);\n  }\n  except((GetExceptionCode() == STATUS_INTEGER_OVERFLOW)\n             ? EXCEPTION_EXECUTE_HANDLER\n             : EXCEPTION_CONTINUE_SEARCH) {\n    Counter += 1;\n  }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n//\n// Simple try that raises an misaligned data exception.\n//\n#if !defined(i386) && !defined(_M_IA64) && !defined(_M_AMD64) &&               \\\n    !defined(_M_ARM) && !defined(_M_ARM64)\n  printf("    test29...");\n  Counter = 0;\n  try {\n    Counter += 1;\n    foo2(BlackHole, (PLONG)BadByte);\n  }\n  except((GetExceptionCode() == STATUS_DATATYPE_MISALIGNMENT)\n             ? EXCEPTION_EXECUTE_HANDLER\n             : EXCEPTION_CONTINUE_SEARCH) {\n    Counter += 1;\n  }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n#endif\n  //\n  // Continue from a try body with an exception clause in a loop.\n  //\n\n  printf("    test30...");\n  Counter = 0;\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\n    try {\n      if ((Index1 & 0x1) == 0) {\n        continue;\n\n      } else {\n        Counter += 1;\n      }\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 40; }\n\n    Counter += 2;\n  }\n\n  if (Counter != 15) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n#if !defined(WIN_CE) // gotos from try/finally not allowed on WinCE\n  //\n  // Continue from a try body with an finally clause in a loop.\n  //\n\n  printf("    test31...");\n  Counter = 0;\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\n    try {\n      if ((Index1 & 0x1) == 0) {\n        continue;\n\n      } else {\n        Counter += 1;\n      }\n    }\n    finally { Counter += 2; }\n\n    Counter += 3;\n  }\n\n  if (Counter != 40) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n#endif\n\n  //\n  // Continue from doubly nested try body with an exception clause in a\n  // loop.\n  //\n\n  printf("    test32...");\n  Counter = 0;\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\n    try {\n      try {\n        if ((Index1 & 0x1) == 0) {\n          continue;\n\n        } else {\n          Counter += 1;\n        }\n      }\n      except(EXCEPTION_EXECUTE_HANDLER) { Counter += 10; }\n\n      Counter += 2;\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 20; }\n\n    Counter += 3;\n  }\n\n  if (Counter != 30) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n#if !defined(WIN_CE) // gotos from try/finally not allowed on WinCE\n  //\n  // Continue from doubly nested try body with an finally clause in a loop.\n  //\n\n  printf("    test33...");\n  Counter = 0;\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\n    try {\n      try {\n        if ((Index1 & 0x1) == 0) {\n          continue;\n\n        } else {\n          Counter += 1;\n        }\n      }\n      finally { Counter += 2; }\n\n      Counter += 3;\n    }\n    finally { Counter += 4; }\n\n    Counter += 5;\n  }\n\n  if (Counter != 105) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Continue from a finally clause in a loop.\n  //\n\n  printf("    test34...");\n  Counter = 0;\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\n    try {\n      if ((Index1 & 0x1) == 0) {\n        Counter += 1;\n      }\n    }\n    finally {\n      Counter += 2;\n      continue;\n    }\n\n    Counter += 4;\n  }\n\n  if (Counter != 25) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Continue from a doubly nested finally clause in a loop.\n  //\n\n  printf("    test35...");\n  Counter = 0;\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\n    try {\n      try {\n        if ((Index1 & 0x1) == 0) {\n          Counter += 1;\n        }\n      }\n      finally {\n        Counter += 2;\n        continue;\n      }\n\n      Counter += 4;\n    }\n    finally { Counter += 5; }\n\n    Counter += 6;\n  }\n\n  if (Counter != 75) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Continue from a doubly nested finally clause in a loop.\n  //\n\n  printf("    test36...");\n  Counter = 0;\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\n    try {\n      try {\n        if ((Index1 & 0x1) == 0) {\n          Counter += 1;\n        }\n      }\n      finally { Counter += 2; }\n\n      Counter += 4;\n    }\n    finally {\n      Counter += 5;\n      continue;\n    }\n\n    Counter += 6;\n  }\n\n  if (Counter != 115) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n#endif\n\n  //\n  // Break from a try body with an exception clause in a loop.\n  //\n\n  printf("    test37...");\n  Counter = 0;\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\n    try {\n      if ((Index1 & 0x1) == 1) {\n        break;\n\n      } else {\n        Counter += 1;\n      }\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 40; }\n\n    Counter += 2;\n  }\n\n  if (Counter != 3) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n#if !defined(WIN_CE) // gotos from try/finally not allowed on WinCE\n  //\n  // Break from a try body with an finally clause in a loop.\n  //\n\n  printf("    test38...");\n  Counter = 0;\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\n    try {\n      if ((Index1 & 0x1) == 1) {\n        break;\n\n      } else {\n        Counter += 1;\n      }\n    }\n    finally { Counter += 2; }\n\n    Counter += 3;\n  }\n\n  if (Counter != 8) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n#endif\n\n  //\n  // Break from doubly nested try body with an exception clause in a\n  // loop.\n  //\n\n  printf("    test39...");\n  Counter = 0;\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\n    try {\n      try {\n        if ((Index1 & 0x1) == 1) {\n          break;\n\n        } else {\n          Counter += 1;\n        }\n      }\n      except(EXCEPTION_EXECUTE_HANDLER) { Counter += 10; }\n\n      Counter += 2;\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 20; }\n\n    Counter += 3;\n  }\n\n  if (Counter != 6) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n#if !defined(WIN_CE) // gotos from try/finally not allowed on WinCE\n  //\n  // Break from doubly nested try body with an finally clause in a loop.\n  //\n\n  printf("    test40...");\n  Counter = 0;\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\n    try {\n      try {\n        if ((Index1 & 0x1) == 1) {\n          break;\n\n        } else {\n          Counter += 1;\n        }\n      }\n      finally { Counter += 2; }\n\n      Counter += 3;\n    }\n    finally { Counter += 4; }\n\n    Counter += 5;\n  }\n\n  if (Counter != 21) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Break from a finally clause in a loop.\n  //\n\n  printf("    test41...");\n  Counter = 0;\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\n    try {\n      if ((Index1 & 0x1) == 1) {\n        Counter += 1;\n      }\n    }\n    finally {\n      Counter += 2;\n      break;\n    }\n\n    Counter += 4;\n  }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Break from a doubly nested finally clause in a loop.\n  //\n\n  printf("    test42...");\n  Counter = 0;\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\n    try {\n      try {\n        if ((Index1 & 0x1) == 1) {\n          Counter += 1;\n        }\n      }\n      finally {\n        Counter += 2;\n        break;\n      }\n\n      Counter += 4;\n    }\n    finally { Counter += 5; }\n\n    Counter += 6;\n  }\n\n  if (Counter != 7) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Break from a doubly nested finally clause in a loop.\n  //\n\n  printf("    test43...");\n  Counter = 0;\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\n    try {\n      try {\n        if ((Index1 & 0x1) == 1) {\n          Counter += 1;\n        }\n      }\n      finally { Counter += 2; }\n\n      Counter += 4;\n    }\n    finally {\n      Counter += 5;\n      break;\n    }\n\n    Counter += 6;\n  }\n\n  if (Counter != 11) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n#endif\n\n  //\n  // Break from a try body with an exception clause in a switch.\n  //\n\n  printf("    test44...");\n  Counter = 0;\n  Index1 = 1;\n  switch (Index2) {\n  case BLUE:\n    Counter += 100;\n    break;\n\n  case RED:\n    try {\n      if ((Index1 & 0x1) == 1) {\n        break;\n\n      } else {\n        Counter += 1;\n      }\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 40; }\n\n    Counter += 2;\n    break;\n  }\n\n  if (Counter != 0) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n#if !defined(WIN_CE) // gotos from try/finally not allowed on WinCE\n  //\n  // Break from a try body with an finally clause in a switch.\n  //\n\n  printf("    test45...");\n  Counter = 0;\n  Index1 = 1;\n  switch (Index2) {\n  case BLUE:\n    Counter += 100;\n    break;\n\n  case RED:\n    try {\n      if ((Index1 & 0x1) == 1) {\n        break;\n\n      } else {\n        Counter += 1;\n      }\n    }\n    finally { Counter += 2; }\n\n    Counter += 3;\n  }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n#endif\n\n  //\n  // Break from doubly nested try body with an exception clause in a\n  // switch.\n  //\n\n  printf("    test46...");\n  Counter = 0;\n  Index1 = 1;\n  switch (Index2) {\n  case BLUE:\n    Counter += 100;\n    break;\n\n  case RED:\n    try {\n      try {\n        if ((Index1 & 0x1) == 1) {\n          break;\n\n        } else {\n          Counter += 1;\n        }\n      }\n      except(EXCEPTION_EXECUTE_HANDLER) { Counter += 10; }\n\n      Counter += 2;\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 20; }\n\n    Counter += 3;\n  }\n\n  if (Counter != 0) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n#if !defined(WIN_CE) // gotos from try/finally not allowed on WinCE\n  //\n  // Break from doubly nested try body with an finally clause in a switch.\n  //\n\n  printf("    test47...");\n  Counter = 0;\n  Index1 = 1;\n  switch (Index2) {\n  case BLUE:\n    Counter += 100;\n    break;\n\n  case RED:\n    try {\n      try {\n        if ((Index1 & 0x1) == 1) {\n          break;\n\n        } else {\n          Counter += 1;\n        }\n      }\n      finally { Counter += 2; }\n\n      Counter += 3;\n    }\n    finally { Counter += 4; }\n\n    Counter += 5;\n  }\n\n  if (Counter != 6) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Break from a finally clause in a switch.\n  //\n\n  printf("    test48...");\n  Counter = 0;\n  Index1 = 1;\n  switch (Index2) {\n  case BLUE:\n    Counter += 100;\n    break;\n\n  case RED:\n    try {\n      if ((Index1 & 0x1) == 1) {\n        Counter += 1;\n      }\n    }\n    finally {\n      Counter += 2;\n      break;\n    }\n\n    Counter += 4;\n  }\n\n  if (Counter != 3) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Break from a doubly nested finally clause in a switch.\n  //\n\n  printf("    test49...");\n  Counter = 0;\n  Index1 = 1;\n  switch (Index2) {\n  case BLUE:\n    Counter += 100;\n    break;\n\n  case RED:\n    try {\n      try {\n        if ((Index1 & 0x1) == 1) {\n          Counter += 1;\n        }\n      }\n      finally {\n        Counter += 2;\n        break;\n      }\n\n      Counter += 4;\n    }\n    finally { Counter += 5; }\n\n    Counter += 6;\n  }\n\n  if (Counter != 8) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Break from a doubly nested finally clause in a switch.\n  //\n\n  printf("    test50...");\n  Counter = 0;\n  Index1 = 1;\n  switch (Index2) {\n  case BLUE:\n    Counter += 100;\n    break;\n\n  case RED:\n    try {\n      try {\n        if ((Index1 & 0x1) == 1) {\n          Counter += 1;\n        }\n      }\n      finally { Counter += 2; }\n\n      Counter += 4;\n    }\n    finally {\n      Counter += 5;\n      break;\n    }\n\n    Counter += 6;\n  }\n\n  if (Counter != 12) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n#endif\n\n  //\n  // Leave from an if in a simple try/finally.\n  //\n\n  printf("    test51...");\n  Counter = 0;\n  try {\n    if (Echo(Counter) == Counter) {\n      Counter += 3;\n      leave;\n\n    } else {\n      Counter += 100;\n    }\n  }\n  finally {\n    if (abnormal_termination() == FALSE) {\n      Counter += 5;\n    }\n  }\n\n  if (Counter != 8) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Leave from a loop in a simple try/finally.\n  //\n\n  printf("    test52...");\n  Counter = 0;\n  try {\n    for (Index1 = 0; Index1 < 10; Index1 += 1) {\n      if (Echo(Index1) == Index1) {\n        Counter += 3;\n        leave;\n      }\n\n      Counter += 100;\n    }\n  }\n  finally {\n    if (abnormal_termination() == FALSE) {\n      Counter += 5;\n    }\n  }\n\n  if (Counter != 8) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Leave from a switch in a simple try/finally.\n  //\n\n  printf("    test53...");\n  Counter = 0;\n  try {\n    switch (Index2) {\n    case BLUE:\n      break;\n\n    case RED:\n      Counter += 3;\n      leave;\n    }\n\n    Counter += 100;\n  }\n  finally {\n    if (abnormal_termination() == FALSE) {\n      Counter += 5;\n    }\n  }\n\n  if (Counter != 8) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Leave from an if in doubly nested try/finally followed by a leave\n  // from an if in the outer try/finally.\n  //\n\n  printf("    test54...");\n  Counter = 0;\n  try {\n    try {\n      if (Echo(Counter) == Counter) {\n        Counter += 3;\n        leave;\n\n      } else {\n        Counter += 100;\n      }\n    }\n    finally {\n      if (abnormal_termination() == FALSE) {\n        Counter += 5;\n      }\n    }\n\n    if (Echo(Counter) == Counter) {\n      Counter += 3;\n      leave;\n\n    } else {\n      Counter += 100;\n    }\n  }\n  finally {\n    if (abnormal_termination() == FALSE) {\n      Counter += 5;\n    }\n  }\n\n  if (Counter != 16) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n#if !defined(WIN_CE) // leave from finally not allowed on WinCE\n  //\n  // Leave from an if in doubly nested try/finally followed by a leave\n  // from the finally of the outer try/finally.\n  //\n\n  printf("    test55...");\n  Counter = 0;\n  try {\n    try {\n      if (Echo(Counter) == Counter) {\n        Counter += 3;\n        leave;\n\n      } else {\n        Counter += 100;\n      }\n    }\n    finally {\n      if (abnormal_termination() == FALSE) {\n        Counter += 5;\n        leave;\n      }\n    }\n\n    Counter += 100;\n  }\n  finally {\n    if (abnormal_termination() == FALSE) {\n      Counter += 5;\n    }\n  }\n\n  if (Counter != 13) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n#endif\n\n  //\n  // Try/finally within the except clause of a try/except that is always\n  // executed.\n  //\n\n  printf("    test56...");\n  Counter = 0;\n  try {\n    Counter += 1;\n    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n  }\n  except(Counter) {\n    try {\n      Counter += 3;\n    }\n    finally {\n      if (abnormal_termination() == FALSE) {\n        Counter += 5;\n      }\n    }\n  }\n\n  if (Counter != 9) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Try/finally within the finally clause of a try/finally.\n  //\n\n  printf("    test57...");\n  Counter = 0;\n  try {\n    Counter += 1;\n  }\n  finally {\n    if (abnormal_termination() == FALSE) {\n      try {\n        Counter += 3;\n      }\n      finally {\n        if (abnormal_termination() == FALSE) {\n          Counter += 5;\n        }\n      }\n    }\n  }\n\n  if (Counter != 9) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Try/except within the finally clause of a try/finally.\n  //\n\n  printf("    test58...");\n#if !defined(NEST_IN_FINALLY)\n  printf("skipped\\n");\n#else\n  Counter = 0;\n  try {\n    Counter -= 1;\n  }\n  finally {\n    try {\n      Counter += 2;\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n    }\n    except(Counter) {\n      try {\n        Counter += 3;\n      }\n      finally {\n        if (abnormal_termination() == FALSE) {\n          Counter += 5;\n        }\n      }\n    }\n  }\n\n  if (Counter != 9) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n#endif /* def(NEST_IN_FINALLY) */\n\n  //\n  // Try/except within the except clause of a try/except that is always\n  // executed.\n  //\n\n  printf("    test59...");\n  Counter = 0;\n  try {\n    Counter += 1;\n    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n  }\n  except(Counter) {\n    try {\n      Counter += 3;\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n    }\n    except(Counter - 3) { Counter += 5; }\n  }\n\n  if (Counter != 9) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Try with a Try which exits the scope with a goto\n  //\n\n  printf("    test60...");\n  Counter = 0;\n  try {\n    try {\n      goto outside;\n    }\n    except(1) { Counter += 1; }\n\n  outside:\n    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n  }\n  except(1) { Counter += 3; }\n\n  if (Counter != 3) {\n    printf("failed, count = %d\\n", Counter);\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Try/except which gets an exception from a subfunction within\n  // a try/finally which has a try/except in the finally clause\n  //\n\n  printf("    test61...");\n#if !defined(NEST_IN_FINALLY)\n  printf("skipped\\n");\n#else\n  Counter = 0;\n  try {\n    Test61Part2(&Counter);\n  }\n  except(EXCEPTION_EXECUTE_HANDLER) { Counter += 11; }\n\n  if (Counter != 24) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n#endif /* def(NEST_IN_FINALLY) */\n\n  //\n  // Check for precision of exception on floating point\n  //\n\n  printf("    test62...");\n\n#if defined(i386) || defined(_M_IA64) || defined(_M_ALPHA) || defined(_M_AMD64)\n\n/* enable floating point overflow */\n#if defined(i386)\n  _control87(_control87(0, 0) & ~EM_OVERFLOW, _MCW_EM);\n#else\n  //\n  // use portable version of _control87\n  //\n  _controlfp(_controlfp(0, 0) & ~EM_OVERFLOW, _MCW_EM);\n#endif\n\n  Counter = 0;\n  try {\n    doubleresult = SquareDouble(1.7e300);\n\n    try {\n      doubleresult = SquareDouble(1.0);\n    }\n    except(1) { Counter += 3; }\n  }\n  except(1) { Counter += 1; }\n\n  if (Counter != 1) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n/* clear up pending unmasked exceptions and restore FP control registers */\n#if defined(i386)\n  _clear87();\n  _control87(_control87(0, 0) | EM_OVERFLOW, 0xfffff);\n#else\n  _clearfp();\n  _controlfp(_controlfp(0, 0) | EM_OVERFLOW, 0xfffff);\n#endif\n\n#else\n  printf("skipped\\n");\n#endif\n\n  //\n  // A try/finally inside a try/except where an exception is raised in the\n  // try/finally.\n  //\n\n  printf("    test63...");\n  Counter = 0;\n  try {\n    try {\n      Counter += 1;\n    }\n    finally {\n      Counter += 3;\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n    }\n  }\n  except(1) { Counter += 6; }\n\n  if (Counter != 10) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A try/finally inside a try/except where an exception is raised in the\n  // in the try/except and the try/finally.\n  //\n\n  printf("    test64...");\n  Counter = 0;\n  try {\n    try {\n      Counter += 1;\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n    }\n    finally {\n      Counter += 3;\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n    }\n  }\n  except(1) { Counter += 6; }\n\n  if (Counter != 10) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A try/finally inside a try/except where an exception is raised in the\n  // try/finally.\n  //\n\n  printf("    test65...");\n  Counter = 0;\n  try {\n    try {\n      Counter += 1;\n    }\n    finally {\n      Counter += 3;\n      *BlackHole += *BadAddress;\n      Counter += 13;\n    }\n  }\n  except(1) { Counter += 6; }\n\n  if (Counter != 10) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A try/finally inside a try/except where an exception is raised in the\n  // in the try/except and the try/finally.\n  //\n\n  printf("    test66...");\n  Counter = 0;\n  try {\n    try {\n      Counter += 1;\n      *BlackHole += *BadAddress;\n      Counter += 13;\n    }\n    finally {\n      Counter += 3;\n      *BlackHole += *BadAddress;\n      Counter += 13;\n    }\n  }\n  except(1) { Counter += 6; }\n\n  if (Counter != 10) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A try/finally inside a try/finally inside a try/except where an\n  // exception is raised in the in the try/except and in try/finally.\n  //\n\n  printf("    test67...");\n  try {\n    try {\n      *BlackHole += *BadAddress;\n    }\n    finally {\n      try {\n        Counter = 0;\n      }\n      finally {\n        if (Counter != 0) {\n          Counter += 1;\n        }\n      }\n\n      Counter += 1;\n      *BlackHole += *BadAddress;\n    }\n  }\n  except(1) { Counter += 1; }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // A try/finally inside a try/finally inside a try/except where an\n  // exception is raised in the in the try/except and in try/finally.\n  //\n\n  printf("    test68...");\n  try {\n    try {\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n    }\n    finally {\n      try {\n        Counter = 0;\n      }\n      finally {\n        if (Counter != 0) {\n          Counter += 1;\n        }\n      }\n\n      Counter += 1;\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n    }\n  }\n  except(1) { Counter += 1; }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n//\n// Patch guard test 69.\n//\n\n#if defined(_AMD64_) || defined(_X86_)\n\n  printf("    test69...");\n  Counter = 0;\n  try {\n    PgTest69(&Counter, BadAddress);\n  }\n  except(EXCEPTION_EXECUTE_HANDLER) { printf("unexpected exception..."); }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  printf("    test70...");\n  Counter = 0;\n  try {\n    PgTest70(&Counter, BadAddress);\n  }\n  except(EXCEPTION_EXECUTE_HANDLER) { printf("unexpected exception..."); }\n\n  if (Counter != 2) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  printf("    test71...");\n  Counter = 0;\n  try {\n    PgTest71(&Counter, BadAddress);\n  }\n  except(EXCEPTION_EXECUTE_HANDLER) { printf("unexpected exception..."); }\n\n  if (Counter != 9) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  printf("    test72...");\n  Counter = 0;\n  try {\n    PgTest72(&Counter, BadAddress);\n  }\n  except(EXCEPTION_EXECUTE_HANDLER) { printf("unexpected exception..."); }\n\n  if (Counter != 12) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  printf("    test73...");\n  Counter = 0;\n  try {\n    PgTest73(&Counter, BadAddress);\n  }\n  except(EXCEPTION_EXECUTE_HANDLER) { printf("unexpected exception..."); }\n\n  if (Counter != 15) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  printf("    test74...");\n  Counter = 0;\n  try {\n    PgTest74(&Counter, BadAddress);\n  }\n  except(EXCEPTION_EXECUTE_HANDLER) { printf("unexpected exception..."); }\n\n  if (Counter != 18) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  printf("    test75...");\n  Counter = 0;\n  try {\n    PgTest75(&Counter, BadAddress);\n  }\n  except(EXCEPTION_EXECUTE_HANDLER) { printf("unexpected exception..."); }\n\n  if (Counter != 35) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  printf("    test76...");\n  Counter = 0;\n  try {\n    PgTest76(&Counter, BadAddress);\n  }\n  except(EXCEPTION_EXECUTE_HANDLER) { printf("unexpected exception..."); }\n\n  if (Counter != 40) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  printf("    test77...");\n  Counter = 0;\n  try {\n    PgTest77(&Counter, BadAddress);\n  }\n  except(EXCEPTION_EXECUTE_HANDLER) { printf("unexpected exception..."); }\n\n  if (Counter != 45) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  printf("    test78...");\n  Counter = 0;\n  try {\n    PgTest78(&Counter, BadAddress);\n  }\n  except(EXCEPTION_EXECUTE_HANDLER) { printf("unexpected exception..."); }\n\n  if (Counter != 50) {\n    printf("failed, count = %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n#else\n  printf("    test69...filter entered...succeeded\\n");\n  printf("    test70...filter entered...succeeded\\n");\n  printf("    test71...filter entered...succeeded\\n");\n  printf("    test72...filter entered...succeeded\\n");\n  printf("    test73...filter entered...succeeded\\n");\n  printf("    test74...filter entered...succeeded\\n");\n  printf("    test75...filter entered...succeeded\\n");\n  printf("    test76...filter entered...succeeded\\n");\n  printf("    test77...filter entered...succeeded\\n");\n  printf("    test78...filter entered...succeeded\\n");\n#endif\n\n  if (LOBYTE(LOWORD(GetVersion())) < 6) {\n    printf("    test79...");\n    printf("filter 1...filter 2...finally 1...filter 1...filter 2...finally "\n           "2...passed\\n");\n  } else {\n\n    printf("    test79...");\n    Counter = 0;\n    try {\n      Test79(&Counter, BadAddress);\n    }\n    except(printf("filter 2..."), EXCEPTION_EXECUTE_HANDLER) { Counter += 1; }\n\n    if (Counter == 3) {\n      printf("passed\\n");\n\n    } else {\n      printf("failed  %d \\n", Counter);\n    }\n  }\n\n  printf("    test80...");\n  if (Test80() != 0) {\n    printf("failed\\n");\n\n  } else {\n    printf("passed\\n");\n  }\n\n  printf("    test81...");\n  Counter = 0;\n  Test81(&Counter);\n  if (Counter != 1) {\n    printf("failed  %d \\n", Counter);\n\n  } else {\n    printf("passed\\n");\n  }\n\n  printf("    test82...");\n  Counter = 1;\n  Test82(&Counter);\n  if (Counter != 0) {\n    printf("failed\\n");\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  printf("    test83...");\n  if (Test83() != 0) {\n    printf("failed\\n");\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  printf("    test84...");\n  Counter = 0;\n  Test84(&Counter);\n  if (Counter != 2) {\n    printf("failed\\n");\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  printf("    test85...");\n  Counter = 0;\n  Test85(&Counter);\n  if (Counter != 7) {\n    printf("failed\\n");\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  printf("    test86...");\n  Counter = 0;\n  Test86(&Counter);\n  if (Counter != 4) {\n    printf("failed %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  printf("    test87...");\n  Counter = 0;\n  Test87(&Counter);\n  if (Counter != 104) {\n    printf("failed %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  printf("    test88...");\n  Counter = 0;\n  Test88(&Counter);\n  if (Counter != 6) {\n    printf("failed %d\\n", Counter);\n\n  } else {\n    printf("succeeded\\n");\n  }\n\n  //\n  // Announce end of exception test.\n  //\n\n  printf("End of exception test\\n");\n  return;\n}\n\n#pragma optimize("a", off)\nVOID addtwo(long First, long Second, long *Place)\n\n{\n\n  RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n  *Place = First + Second;\n  return;\n}\n#pragma optimize("", on)\n\nVOID bar1(IN NTSTATUS Status, IN PLONG Counter) {\n\n  try {\n    foo1(Status);\n  }\n  finally {\n    if (abnormal_termination() != FALSE) {\n      *Counter = 99;\n\n    } else {\n      *Counter = 100;\n    }\n  }\n\n  return;\n}\n\nVOID bar2(IN PLONG BlackHole, IN PLONG BadAddress, IN PLONG Counter) {\n\n  try {\n    foo2(BlackHole, BadAddress);\n  }\n  finally {\n    if (abnormal_termination() != FALSE) {\n      *Counter = 99;\n\n    } else {\n      *Counter = 100;\n    }\n  }\n\n  return;\n}\n\nVOID dojump(IN jmp_buf JumpBuffer, IN PLONG Counter)\n\n{\n\n  try {\n    try {\n      *Counter += 1;\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n    }\n    finally { *Counter += 1; }\n  }\n  finally {\n    *Counter += 1;\n    longjmp(JumpBuffer, 1);\n  }\n}\n\n#if !defined(WIN_CE) // return through finally not allowed on WinCE\nVOID eret(IN NTSTATUS Status, IN PLONG Counter)\n\n{\n\n  try {\n    try {\n      foo1(Status);\n    }\n    except((GetExceptionCode() == Status) ? EXCEPTION_EXECUTE_HANDLER\n                                          : EXCEPTION_CONTINUE_SEARCH) {\n      *Counter += 1;\n      return;\n    }\n  }\n  finally { *Counter += 1; }\n\n  return;\n}\n#endif\n\nVOID except1(IN PLONG Counter)\n\n{\n\n  try {\n    *Counter += 5;\n    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n  }\n  except(except3(GetExceptionInformation(), Counter)) { *Counter += 7; }\n\n  *Counter += 9;\n  return;\n}\n\nULONG\nexcept2(IN PEXCEPTION_POINTERS ExceptionPointers, IN PLONG Counter)\n\n{\n\n  PEXCEPTION_RECORD ExceptionRecord;\n\n  ExceptionRecord = ExceptionPointers->ExceptionRecord;\n  if ((ExceptionRecord->ExceptionCode == STATUS_UNSUCCESSFUL) &&\n      ((ExceptionRecord->ExceptionFlags & EXCEPTION_NESTED_CALL) == 0)) {\n    *Counter += 11;\n    return EXCEPTION_EXECUTE_HANDLER;\n\n  } else {\n    *Counter += 13;\n    return EXCEPTION_CONTINUE_SEARCH;\n  }\n}\n\nULONG\nexcept3(IN PEXCEPTION_POINTERS ExceptionPointers, IN PLONG Counter)\n\n{\n\n  PEXCEPTION_RECORD ExceptionRecord;\n\n  ExceptionRecord = ExceptionPointers->ExceptionRecord;\n  if ((ExceptionRecord->ExceptionCode == STATUS_INTEGER_OVERFLOW) &&\n      ((ExceptionRecord->ExceptionFlags & EXCEPTION_NESTED_CALL) == 0)) {\n    *Counter += 17;\n    RtlRaiseStatus(STATUS_UNSUCCESSFUL);\n\n  } else if ((ExceptionRecord->ExceptionCode == STATUS_UNSUCCESSFUL) &&\n             ((ExceptionRecord->ExceptionFlags & EXCEPTION_NESTED_CALL) != 0)) {\n    *Counter += 19;\n    return EXCEPTION_CONTINUE_SEARCH;\n  }\n\n  *Counter += 23;\n  return EXCEPTION_EXECUTE_HANDLER;\n}\n\nVOID foo1(IN NTSTATUS Status)\n\n{\n\n  //\n  // Raise exception.\n  //\n\n  RtlRaiseStatus(Status);\n  return;\n}\n\nVOID foo2(IN PLONG BlackHole, IN PLONG BadAddress)\n\n{\n\n  //\n  // Raise exception.\n  //\n\n  *BlackHole += *BadAddress;\n  return;\n}\n\n#if !defined(WIN_CE) // return from finally not allowed on WinCE\nVOID fret(IN PLONG Counter)\n\n{\n\n  try {\n    try {\n      *Counter += 1;\n    }\n    finally {\n      *Counter += 1;\n      return;\n    }\n  }\n  finally { *Counter += 1; }\n\n  return;\n}\n#endif\n\nLONG Echo(IN LONG Value)\n\n{\n  return Value;\n}\n\n#if defined(NEST_IN_FINALLY)\nVOID Test61Part2(IN OUT PULONG Counter) {\n  try {\n    *Counter -= 1;\n    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n  }\n  finally {\n    try {\n      *Counter += 2;\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\n    }\n    except(EXCEPTION_EXECUTE_HANDLER) { *Counter += 5; }\n    *Counter += 7;\n  }\n}\n#endif /* def(NEST_IN_FINALLY) */\n\ndouble SquareDouble(IN double op) {\n  return exp(2.0 * log(op));\n}\n'}}]);
//# sourceMappingURL=1401.js.map