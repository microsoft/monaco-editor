import{Position}from"../core/position.js";import{Range}from"../core/range.js";import{countEOL}from"../core/eolCounter.js";export class SparseMultilineTokens{static create(t,e){return new SparseMultilineTokens(t,new SparseMultilineTokensStorage(e))}get startLineNumber(){return this._startLineNumber}get endLineNumber(){return this._endLineNumber}constructor(t,e){this._startLineNumber=t,this._tokens=e,this._endLineNumber=this._startLineNumber+this._tokens.getMaxDeltaLine()}toString(){return this._tokens.toString(this._startLineNumber)}_updateEndLineNumber(){this._endLineNumber=this._startLineNumber+this._tokens.getMaxDeltaLine()}isEmpty(){return this._tokens.isEmpty()}getLineTokens(t){return this._startLineNumber<=t&&t<=this._endLineNumber?this._tokens.getLineTokens(t-this._startLineNumber):null}getRange(){const t=this._tokens.getRange();return t?new Range(this._startLineNumber+t.startLineNumber,t.startColumn,this._startLineNumber+t.endLineNumber,t.endColumn):t}removeTokens(t){const e=t.startLineNumber-this._startLineNumber,n=t.endLineNumber-this._startLineNumber;this._startLineNumber+=this._tokens.removeTokens(e,t.startColumn-1,n,t.endColumn-1),this._updateEndLineNumber()}split(t){const e=t.startLineNumber-this._startLineNumber,n=t.endLineNumber-this._startLineNumber,[s,i,r]=this._tokens.split(e,t.startColumn-1,n,t.endColumn-1);return[new SparseMultilineTokens(this._startLineNumber,s),new SparseMultilineTokens(this._startLineNumber+r,i)]}applyEdit(t,e){const[n,s,i]=countEOL(e);this.acceptEdit(t,n,s,i,e.length>0?e.charCodeAt(0):0)}acceptEdit(t,e,n,s,i){this._acceptDeleteRange(t),this._acceptInsertText(new Position(t.startLineNumber,t.startColumn),e,n,s,i),this._updateEndLineNumber()}_acceptDeleteRange(t){if(t.startLineNumber===t.endLineNumber&&t.startColumn===t.endColumn)return;const e=t.startLineNumber-this._startLineNumber,n=t.endLineNumber-this._startLineNumber;if(n<0){const t=n-e;return void(this._startLineNumber-=t)}const s=this._tokens.getMaxDeltaLine();if(!(e>=s+1)){if(e<0&&n>=s+1)return this._startLineNumber=0,void this._tokens.clear();if(e<0){const s=-e;this._startLineNumber-=s,this._tokens.acceptDeleteRange(t.startColumn-1,0,0,n,t.endColumn-1)}else this._tokens.acceptDeleteRange(0,e,t.startColumn-1,n,t.endColumn-1)}}_acceptInsertText(t,e,n,s,i){if(0===e&&0===n)return;const r=t.lineNumber-this._startLineNumber;r<0?this._startLineNumber+=e:r>=this._tokens.getMaxDeltaLine()+1||this._tokens.acceptInsertText(r,t.column-1,e,n,s,i)}}class SparseMultilineTokensStorage{constructor(t){this._tokens=t,this._tokenCount=t.length/4}toString(t){const e=[];for(let n=0;n<this._tokenCount;n++)e.push(`(${this._getDeltaLine(n)+t},${this._getStartCharacter(n)}-${this._getEndCharacter(n)})`);return`[${e.join(",")}]`}getMaxDeltaLine(){const t=this._getTokenCount();return 0===t?-1:this._getDeltaLine(t-1)}getRange(){const t=this._getTokenCount();if(0===t)return null;const e=this._getStartCharacter(0),n=this._getDeltaLine(t-1),s=this._getEndCharacter(t-1);return new Range(0,e+1,n,s+1)}_getTokenCount(){return this._tokenCount}_getDeltaLine(t){return this._tokens[4*t]}_getStartCharacter(t){return this._tokens[4*t+1]}_getEndCharacter(t){return this._tokens[4*t+2]}isEmpty(){return 0===this._getTokenCount()}getLineTokens(t){let e=0,n=this._getTokenCount()-1;for(;e<n;){const s=e+Math.floor((n-e)/2),i=this._getDeltaLine(s);if(i<t)e=s+1;else{if(!(i>t)){let i=s;for(;i>e&&this._getDeltaLine(i-1)===t;)i--;let r=s;for(;r<n&&this._getDeltaLine(r+1)===t;)r++;return new SparseLineTokens(this._tokens.subarray(4*i,4*r+4))}n=s-1}}return this._getDeltaLine(e)===t?new SparseLineTokens(this._tokens.subarray(4*e,4*e+4)):null}clear(){this._tokenCount=0}removeTokens(t,e,n,s){const i=this._tokens,r=this._tokenCount;let o=0,a=!1,u=0;for(let h=0;h<r;h++){const r=4*h,l=i[r],_=i[r+1],c=i[r+2],m=i[r+3];if((l>t||l===t&&c>=e)&&(l<n||l===n&&_<=s))a=!0;else{if(0===o&&(u=l),a){const t=4*o;i[t]=l-u,i[t+1]=_,i[t+2]=c,i[t+3]=m}o++}}return this._tokenCount=o,u}split(t,e,n,s){const i=this._tokens,r=this._tokenCount,o=[],a=[];let u=o,h=0,l=0;for(let o=0;o<r;o++){const r=4*o,_=i[r],c=i[r+1],m=i[r+2],L=i[r+3];if(_>t||_===t&&m>=e){if(_<n||_===n&&c<=s)continue;u!==a&&(u=a,h=0,l=_)}u[h++]=_-l,u[h++]=c,u[h++]=m,u[h++]=L}return[new SparseMultilineTokensStorage(new Uint32Array(o)),new SparseMultilineTokensStorage(new Uint32Array(a)),l]}acceptDeleteRange(t,e,n,s,i){const r=this._tokens,o=this._tokenCount,a=s-e;let u=0,h=!1;for(let l=0;l<o;l++){const _=4*l;let c=r[_],m=r[_+1],L=r[_+2];const k=r[_+3];if(c<e||c===e&&L<=n){u++;continue}if(c===e&&m<n)c===s&&L>i?L-=i-n:L=n;else if(c===e&&m===n){if(!(c===s&&L>i)){h=!0;continue}L-=i-n}else if(c<s||c===s&&m<i){if(!(c===s&&L>i)){h=!0;continue}c===e?(m=n,L=m+(L-i)):(m=0,L=m+(L-i))}else if(c>s){if(0===a&&!h){u=o;break}c-=a}else{if(!(c===s&&m>=i))throw new Error("Not possible!");t&&0===c&&(m+=t,L+=t),c-=a,m-=i-n,L-=i-n}const g=4*u;r[g]=c,r[g+1]=m,r[g+2]=L,r[g+3]=k,u++}this._tokenCount=u}acceptInsertText(t,e,n,s,i,r){const o=0===n&&1===s&&(r>=48&&r<=57||r>=65&&r<=90||r>=97&&r<=122),a=this._tokens,u=this._tokenCount;for(let r=0;r<u;r++){const u=4*r;let h=a[u],l=a[u+1],_=a[u+2];if(!(h<t||h===t&&_<e)){if(h===t&&_===e){if(!o)continue;_+=1}else if(h===t&&l<e&&e<_)0===n?_+=s:_=e;else{if(h===t&&l===e&&o)continue;if(h===t)if(h+=n,0===n)l+=s,_+=s;else{const t=_-l;l=i+(l-e),_=l+t}else h+=n}a[u]=h,a[u+1]=l,a[u+2]=_}}}}export class SparseLineTokens{constructor(t){this._tokens=t}getCount(){return this._tokens.length/4}getStartCharacter(t){return this._tokens[4*t+1]}getEndCharacter(t){return this._tokens[4*t+2]}getMetadata(t){return this._tokens[4*t+3]}}