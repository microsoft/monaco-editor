import{transformErrorForSerialization}from"../errors.js";import{Emitter}from"../event.js";import{Disposable}from"../lifecycle.js";import{getAllMethodNames}from"../objects.js";import{globals,isWeb}from"../platform.js";import*as strings from"../strings.js";const INITIALIZE="$initialize";let webWorkerWarningLogged=!1;export function logOnceWebWorkerWarning(e){isWeb&&(webWorkerWarningLogged||(webWorkerWarningLogged=!0,console.warn("Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq")),console.warn(e.message))}class RequestMessage{constructor(e,r,s,t){this.vsWorker=e,this.req=r,this.method=s,this.args=t,this.type=0}}class ReplyMessage{constructor(e,r,s,t){this.vsWorker=e,this.seq=r,this.res=s,this.err=t,this.type=1}}class SubscribeEventMessage{constructor(e,r,s,t){this.vsWorker=e,this.req=r,this.eventName=s,this.arg=t,this.type=2}}class EventMessage{constructor(e,r,s){this.vsWorker=e,this.req=r,this.event=s,this.type=3}}class UnsubscribeEventMessage{constructor(e,r){this.vsWorker=e,this.req=r,this.type=4}}class SimpleWorkerProtocol{constructor(e){this._workerId=-1,this._handler=e,this._lastSentReq=0,this._pendingReplies=Object.create(null),this._pendingEmitters=new Map,this._pendingEvents=new Map}setWorkerId(e){this._workerId=e}sendMessage(e,r){const s=String(++this._lastSentReq);return new Promise(((t,n)=>{this._pendingReplies[s]={resolve:t,reject:n},this._send(new RequestMessage(this._workerId,s,e,r))}))}listen(e,r){let s=null;const t=new Emitter({onWillAddFirstListener:()=>{s=String(++this._lastSentReq),this._pendingEmitters.set(s,t),this._send(new SubscribeEventMessage(this._workerId,s,e,r))},onDidRemoveLastListener:()=>{this._pendingEmitters.delete(s),this._send(new UnsubscribeEventMessage(this._workerId,s)),s=null}});return t.event}handleMessage(e){e&&e.vsWorker&&(-1!==this._workerId&&e.vsWorker!==this._workerId||this._handleMessage(e))}_handleMessage(e){switch(e.type){case 1:return this._handleReplyMessage(e);case 0:return this._handleRequestMessage(e);case 2:return this._handleSubscribeEventMessage(e);case 3:return this._handleEventMessage(e);case 4:return this._handleUnsubscribeEventMessage(e)}}_handleReplyMessage(e){if(!this._pendingReplies[e.seq])return void console.warn("Got reply to unknown seq");const r=this._pendingReplies[e.seq];if(delete this._pendingReplies[e.seq],e.err){let s=e.err;return e.err.$isError&&(s=new Error,s.name=e.err.name,s.message=e.err.message,s.stack=e.err.stack),void r.reject(s)}r.resolve(e.res)}_handleRequestMessage(e){const r=e.req;this._handler.handleMessage(e.method,e.args).then((e=>{this._send(new ReplyMessage(this._workerId,r,e,void 0))}),(e=>{e.detail instanceof Error&&(e.detail=transformErrorForSerialization(e.detail)),this._send(new ReplyMessage(this._workerId,r,void 0,transformErrorForSerialization(e)))}))}_handleSubscribeEventMessage(e){const r=e.req,s=this._handler.handleEvent(e.eventName,e.arg)((e=>{this._send(new EventMessage(this._workerId,r,e))}));this._pendingEvents.set(r,s)}_handleEventMessage(e){this._pendingEmitters.has(e.req)?this._pendingEmitters.get(e.req).fire(e.event):console.warn("Got event for unknown req")}_handleUnsubscribeEventMessage(e){this._pendingEvents.has(e.req)?(this._pendingEvents.get(e.req).dispose(),this._pendingEvents.delete(e.req)):console.warn("Got unsubscribe for unknown req")}_send(e){const r=[];if(0===e.type)for(let s=0;s<e.args.length;s++)e.args[s]instanceof ArrayBuffer&&r.push(e.args[s]);else 1===e.type&&e.res instanceof ArrayBuffer&&r.push(e.res);this._handler.sendMessage(e,r)}}export class SimpleWorkerClient extends Disposable{constructor(e,r,s){super();let t=null;this._worker=this._register(e.create("vs/base/common/worker/simpleWorker",(e=>{this._protocol.handleMessage(e)}),(e=>{null==t||t(e)}))),this._protocol=new SimpleWorkerProtocol({sendMessage:(e,r)=>{this._worker.postMessage(e,r)},handleMessage:(e,r)=>{if("function"!=typeof s[e])return Promise.reject(new Error("Missing method "+e+" on main thread host."));try{return Promise.resolve(s[e].apply(s,r))}catch(e){return Promise.reject(e)}},handleEvent:(e,r)=>{if(propertyIsDynamicEvent(e)){const t=s[e].call(s,r);if("function"!=typeof t)throw new Error(`Missing dynamic event ${e} on main thread host.`);return t}if(propertyIsEvent(e)){const r=s[e];if("function"!=typeof r)throw new Error(`Missing event ${e} on main thread host.`);return r}throw new Error(`Malformed event name ${e}`)}}),this._protocol.setWorkerId(this._worker.getId());let n=null;void 0!==globals.require&&"function"==typeof globals.require.getConfig?n=globals.require.getConfig():void 0!==globals.requirejs&&(n=globals.requirejs.s.contexts._.config);const o=getAllMethodNames(s);this._onModuleLoaded=this._protocol.sendMessage(INITIALIZE,[this._worker.getId(),JSON.parse(JSON.stringify(n)),r,o]);const i=(e,r)=>this._request(e,r),a=(e,r)=>this._protocol.listen(e,r);this._lazyProxy=new Promise(((e,s)=>{t=s,this._onModuleLoaded.then((r=>{e(createProxyObject(r,i,a))}),(e=>{s(e),this._onError("Worker failed to load "+r,e)}))}))}getProxyObject(){return this._lazyProxy}_request(e,r){return new Promise(((s,t)=>{this._onModuleLoaded.then((()=>{this._protocol.sendMessage(e,r).then(s,t)}),t)}))}_onError(e,r){console.error(e),console.info(r)}}function propertyIsEvent(e){return"o"===e[0]&&"n"===e[1]&&strings.isUpperAsciiLetter(e.charCodeAt(2))}function propertyIsDynamicEvent(e){return/^onDynamic/.test(e)&&strings.isUpperAsciiLetter(e.charCodeAt(9))}function createProxyObject(e,r,s){const t=e=>function(){const s=Array.prototype.slice.call(arguments,0);return r(e,s)},n=e=>function(r){return s(e,r)},o={};for(const r of e)propertyIsDynamicEvent(r)?o[r]=n(r):propertyIsEvent(r)?o[r]=s(r,void 0):o[r]=t(r);return o}export class SimpleWorkerServer{constructor(e,r){this._requestHandlerFactory=r,this._requestHandler=null,this._protocol=new SimpleWorkerProtocol({sendMessage:(r,s)=>{e(r,s)},handleMessage:(e,r)=>this._handleMessage(e,r),handleEvent:(e,r)=>this._handleEvent(e,r)})}onmessage(e){this._protocol.handleMessage(e)}_handleMessage(e,r){if(e===INITIALIZE)return this.initialize(r[0],r[1],r[2],r[3]);if(!this._requestHandler||"function"!=typeof this._requestHandler[e])return Promise.reject(new Error("Missing requestHandler or method: "+e));try{return Promise.resolve(this._requestHandler[e].apply(this._requestHandler,r))}catch(e){return Promise.reject(e)}}_handleEvent(e,r){if(!this._requestHandler)throw new Error("Missing requestHandler");if(propertyIsDynamicEvent(e)){const s=this._requestHandler[e].call(this._requestHandler,r);if("function"!=typeof s)throw new Error(`Missing dynamic event ${e} on request handler.`);return s}if(propertyIsEvent(e)){const r=this._requestHandler[e];if("function"!=typeof r)throw new Error(`Missing event ${e} on request handler.`);return r}throw new Error(`Malformed event name ${e}`)}initialize(e,r,s,t){this._protocol.setWorkerId(e);const n=createProxyObject(t,((e,r)=>this._protocol.sendMessage(e,r)),((e,r)=>this._protocol.listen(e,r)));return this._requestHandlerFactory?(this._requestHandler=this._requestHandlerFactory(n),Promise.resolve(getAllMethodNames(this._requestHandler))):(r&&(void 0!==r.baseUrl&&delete r.baseUrl,void 0!==r.paths&&void 0!==r.paths.vs&&delete r.paths.vs,void 0!==typeof r.trustedTypesPolicy&&delete r.trustedTypesPolicy,r.catchError=!0,globals.require.config(r)),new Promise(((e,r)=>{(0,globals.require)([s],(s=>{this._requestHandler=s.create(n),this._requestHandler?e(getAllMethodNames(this._requestHandler)):r(new Error("No RequestHandler!"))}),r)})))}}export function create(e){return new SimpleWorkerServer(e,null)}