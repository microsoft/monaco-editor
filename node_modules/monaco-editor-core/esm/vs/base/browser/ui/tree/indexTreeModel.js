import{TreeError}from"./tree.js";import{splice,tail2}from"../../../common/arrays.js";import{Delayer}from"../../../common/async.js";import{MicrotaskDelay}from"../../../common/symbols.js";import{LcsDiff}from"../../../common/diff/diff.js";import{Emitter,EventBufferer}from"../../../common/event.js";import{Iterable}from"../../../common/iterator.js";export function isFilterResult(e){return"object"==typeof e&&"visibility"in e&&"data"in e}export function getVisibleState(e){switch(e){case!0:return 1;case!1:return 0;default:return e}}function isCollapsibleStateUpdate(e){return"boolean"==typeof e.collapsible}export class IndexTreeModel{constructor(e,t,i,l={}){this.user=e,this.list=t,this.rootRef=[],this.eventBufferer=new EventBufferer,this._onDidChangeCollapseState=new Emitter,this.onDidChangeCollapseState=this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event),this._onDidChangeRenderNodeCount=new Emitter,this.onDidChangeRenderNodeCount=this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event),this._onDidSplice=new Emitter,this.onDidSplice=this._onDidSplice.event,this.refilterDelayer=new Delayer(MicrotaskDelay),this.collapseByDefault=void 0!==l.collapseByDefault&&l.collapseByDefault,this.filter=l.filter,this.autoExpandSingleChildren=void 0!==l.autoExpandSingleChildren&&l.autoExpandSingleChildren,this.root={parent:void 0,element:i,children:[],depth:0,visibleChildrenCount:0,visibleChildIndex:-1,collapsible:!1,collapsed:!1,renderNodeCount:0,visibility:1,visible:!0,filterData:void 0}}splice(e,t,i=Iterable.empty(),l={}){if(0===e.length)throw new TreeError(this.user,"Invalid tree location");l.diffIdentityProvider?this.spliceSmart(l.diffIdentityProvider,e,t,i,l):this.spliceSimple(e,t,i,l)}spliceSmart(e,t,i,l,r,o){var n;void 0===l&&(l=Iterable.empty()),void 0===o&&(o=null!==(n=r.diffDepth)&&void 0!==n?n:0);const{parentNode:s}=this.getParentNodeWithListIndex(t);if(!s.lastDiffIds)return this.spliceSimple(t,i,l,r);const d=[...l],a=t[t.length-1],h=new LcsDiff({getElements:()=>s.lastDiffIds},{getElements:()=>[...s.children.slice(0,a),...d,...s.children.slice(a+i)].map((t=>e.getId(t.element).toString()))}).ComputeDiff(!1);if(h.quitEarly)return s.lastDiffIds=void 0,this.spliceSimple(t,i,d,r);const c=t.slice(0,-1),p=(t,i,l)=>{if(o>0)for(let n=0;n<l;n++)t--,i--,this.spliceSmart(e,[...c,t,0],Number.MAX_SAFE_INTEGER,d[i].children,r,o-1)};let f=Math.min(s.children.length,a+i),u=d.length;for(const e of h.changes.sort(((e,t)=>t.originalStart-e.originalStart)))p(f,u,f-(e.originalStart+e.originalLength)),f=e.originalStart,u=e.modifiedStart-a,this.spliceSimple([...c,f],e.originalLength,Iterable.slice(d,u,u+e.modifiedLength),r);p(f,u,f)}spliceSimple(e,t,i=Iterable.empty(),{onDidCreateNode:l,onDidDeleteNode:r,diffIdentityProvider:o}){const{parentNode:n,listIndex:s,revealed:d,visible:a}=this.getParentNodeWithListIndex(e),h=[],c=Iterable.map(i,(e=>this.createTreeNode(e,n,n.visible?1:0,d,h,l))),p=e[e.length-1],f=n.children.length>0;let u=0;for(let e=p;e>=0&&e<n.children.length;e--){const t=n.children[e];if(t.visible){u=t.visibleChildIndex;break}}const C=[];let v=0,g=0;for(const e of c)C.push(e),g+=e.renderNodeCount,e.visible&&(e.visibleChildIndex=u+v++);const b=splice(n.children,p,t,C);o?n.lastDiffIds?splice(n.lastDiffIds,p,t,C.map((e=>o.getId(e.element).toString()))):n.lastDiffIds=n.children.map((e=>o.getId(e.element).toString())):n.lastDiffIds=void 0;let N=0;for(const e of b)e.visible&&N++;if(0!==N)for(let e=p+C.length;e<n.children.length;e++){const t=n.children[e];t.visible&&(t.visibleChildIndex-=N)}if(n.visibleChildrenCount+=v-N,d&&a){const e=b.reduce(((e,t)=>e+(t.visible?t.renderNodeCount:0)),0);this._updateAncestorsRenderNodeCount(n,g-e),this.list.splice(s,e,h)}if(b.length>0&&r){const e=t=>{r(t),t.children.forEach(e)};b.forEach(e)}this._onDidSplice.fire({insertedNodes:C,deletedNodes:b});const m=n.children.length>0;f!==m&&this.setCollapsible(e.slice(0,-1),m);let I=n;for(;I;){if(2===I.visibility){this.refilterDelayer.trigger((()=>this.refilter()));break}I=I.parent}}rerender(e){if(0===e.length)throw new TreeError(this.user,"Invalid tree location");const{node:t,listIndex:i,revealed:l}=this.getTreeNodeWithListIndex(e);t.visible&&l&&this.list.splice(i,1,[t])}has(e){return this.hasTreeNode(e)}getListIndex(e){const{listIndex:t,visible:i,revealed:l}=this.getTreeNodeWithListIndex(e);return i&&l?t:-1}getListRenderCount(e){return this.getTreeNode(e).renderNodeCount}isCollapsible(e){return this.getTreeNode(e).collapsible}setCollapsible(e,t){const i=this.getTreeNode(e);void 0===t&&(t=!i.collapsible);const l={collapsible:t};return this.eventBufferer.bufferEvents((()=>this._setCollapseState(e,l)))}isCollapsed(e){return this.getTreeNode(e).collapsed}setCollapsed(e,t,i){const l=this.getTreeNode(e);void 0===t&&(t=!l.collapsed);const r={collapsed:t,recursive:i||!1};return this.eventBufferer.bufferEvents((()=>this._setCollapseState(e,r)))}_setCollapseState(e,t){const{node:i,listIndex:l,revealed:r}=this.getTreeNodeWithListIndex(e),o=this._setListNodeCollapseState(i,l,r,t);if(i!==this.root&&this.autoExpandSingleChildren&&o&&!isCollapsibleStateUpdate(t)&&i.collapsible&&!i.collapsed&&!t.recursive){let l=-1;for(let e=0;e<i.children.length;e++)if(i.children[e].visible){if(l>-1){l=-1;break}l=e}l>-1&&this._setCollapseState([...e,l],t)}return o}_setListNodeCollapseState(e,t,i,l){const r=this._setNodeCollapseState(e,l,!1);if(!i||!e.visible||!r)return r;const o=e.renderNodeCount,n=this.updateNodeAfterCollapseChange(e),s=o-(-1===t?0:1);return this.list.splice(t+1,s,n.slice(1)),r}_setNodeCollapseState(e,t,i){let l;if(e===this.root?l=!1:(isCollapsibleStateUpdate(t)?(l=e.collapsible!==t.collapsible,e.collapsible=t.collapsible):e.collapsible?(l=e.collapsed!==t.collapsed,e.collapsed=t.collapsed):l=!1,l&&this._onDidChangeCollapseState.fire({node:e,deep:i})),!isCollapsibleStateUpdate(t)&&t.recursive)for(const i of e.children)l=this._setNodeCollapseState(i,t,!0)||l;return l}expandTo(e){this.eventBufferer.bufferEvents((()=>{let t=this.getTreeNode(e);for(;t.parent;)t=t.parent,e=e.slice(0,e.length-1),t.collapsed&&this._setCollapseState(e,{collapsed:!1,recursive:!1})}))}refilter(){const e=this.root.renderNodeCount,t=this.updateNodeAfterFilterChange(this.root);this.list.splice(0,e,t),this.refilterDelayer.cancel()}createTreeNode(e,t,i,l,r,o){const n={parent:t,element:e.element,children:[],depth:t.depth+1,visibleChildrenCount:0,visibleChildIndex:-1,collapsible:"boolean"==typeof e.collapsible?e.collapsible:void 0!==e.collapsed,collapsed:void 0===e.collapsed?this.collapseByDefault:e.collapsed,renderNodeCount:1,visibility:1,visible:!0,filterData:void 0},s=this._filterNode(n,i);n.visibility=s,l&&r.push(n);const d=e.children||Iterable.empty(),a=l&&0!==s&&!n.collapsed;let h=0,c=1;for(const e of d){const t=this.createTreeNode(e,n,s,a,r,o);n.children.push(t),c+=t.renderNodeCount,t.visible&&(t.visibleChildIndex=h++)}return n.collapsible=n.collapsible||n.children.length>0,n.visibleChildrenCount=h,n.visible=2===s?h>0:1===s,n.visible?n.collapsed||(n.renderNodeCount=c):(n.renderNodeCount=0,l&&r.pop()),null==o||o(n),n}updateNodeAfterCollapseChange(e){const t=e.renderNodeCount,i=[];return this._updateNodeAfterCollapseChange(e,i),this._updateAncestorsRenderNodeCount(e.parent,i.length-t),i}_updateNodeAfterCollapseChange(e,t){if(!1===e.visible)return 0;if(t.push(e),e.renderNodeCount=1,!e.collapsed)for(const i of e.children)e.renderNodeCount+=this._updateNodeAfterCollapseChange(i,t);return this._onDidChangeRenderNodeCount.fire(e),e.renderNodeCount}updateNodeAfterFilterChange(e){const t=e.renderNodeCount,i=[];return this._updateNodeAfterFilterChange(e,e.visible?1:0,i),this._updateAncestorsRenderNodeCount(e.parent,i.length-t),i}_updateNodeAfterFilterChange(e,t,i,l=!0){let r;if(e!==this.root){if(r=this._filterNode(e,t),0===r)return e.visible=!1,e.renderNodeCount=0,!1;l&&i.push(e)}const o=i.length;e.renderNodeCount=e===this.root?0:1;let n=!1;if(e.collapsed&&0===r)e.visibleChildrenCount=0;else{let t=0;for(const o of e.children)n=this._updateNodeAfterFilterChange(o,r,i,l&&!e.collapsed)||n,o.visible&&(o.visibleChildIndex=t++);e.visibleChildrenCount=t}return e!==this.root&&(e.visible=2===r?n:1===r,e.visibility=r),e.visible?e.collapsed||(e.renderNodeCount+=i.length-o):(e.renderNodeCount=0,l&&i.pop()),this._onDidChangeRenderNodeCount.fire(e),e.visible}_updateAncestorsRenderNodeCount(e,t){if(0!==t)for(;e;)e.renderNodeCount+=t,this._onDidChangeRenderNodeCount.fire(e),e=e.parent}_filterNode(e,t){const i=this.filter?this.filter.filter(e.element,t):1;return"boolean"==typeof i?(e.filterData=void 0,i?1:0):isFilterResult(i)?(e.filterData=i.data,getVisibleState(i.visibility)):(e.filterData=void 0,getVisibleState(i))}hasTreeNode(e,t=this.root){if(!e||0===e.length)return!0;const[i,...l]=e;return!(i<0||i>t.children.length)&&this.hasTreeNode(l,t.children[i])}getTreeNode(e,t=this.root){if(!e||0===e.length)return t;const[i,...l]=e;if(i<0||i>t.children.length)throw new TreeError(this.user,"Invalid tree location");return this.getTreeNode(l,t.children[i])}getTreeNodeWithListIndex(e){if(0===e.length)return{node:this.root,listIndex:-1,revealed:!0,visible:!1};const{parentNode:t,listIndex:i,revealed:l,visible:r}=this.getParentNodeWithListIndex(e),o=e[e.length-1];if(o<0||o>t.children.length)throw new TreeError(this.user,"Invalid tree location");const n=t.children[o];return{node:n,listIndex:i,revealed:l,visible:r&&n.visible}}getParentNodeWithListIndex(e,t=this.root,i=0,l=!0,r=!0){const[o,...n]=e;if(o<0||o>t.children.length)throw new TreeError(this.user,"Invalid tree location");for(let e=0;e<o;e++)i+=t.children[e].renderNodeCount;return l=l&&!t.collapsed,r=r&&t.visible,0===n.length?{parentNode:t,listIndex:i,revealed:l,visible:r}:this.getParentNodeWithListIndex(n,t.children[o],i+1,l,r)}getNode(e=[]){return this.getTreeNode(e)}getNodeLocation(e){const t=[];let i=e;for(;i.parent;)t.push(i.parent.children.indexOf(i)),i=i.parent;return t.reverse()}getParentNodeLocation(e){return 0===e.length?void 0:1===e.length?[]:tail2(e)[0]}getFirstElementChild(e){const t=this.getTreeNode(e);if(0!==t.children.length)return t.children[0].element}}