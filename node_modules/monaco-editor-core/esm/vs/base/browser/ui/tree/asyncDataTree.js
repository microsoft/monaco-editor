var __awaiter=this&&this.__awaiter||function(e,t,r,s){return new(r||(r=Promise))((function(i,n){function o(e){try{l(s.next(e))}catch(e){n(e)}}function a(e){try{l(s.throw(e))}catch(e){n(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(o,a)}l((s=s.apply(e,t||[])).next())}))};import{ElementsDragAndDropData}from"../list/listView.js";import{ComposedTreeDelegate}from"./abstractTree.js";import{getVisibleState,isFilterResult}from"./indexTreeModel.js";import{CompressibleObjectTree,ObjectTree}from"./objectTree.js";import{TreeError,WeakMapper}from"./tree.js";import{createCancelablePromise,Promises,timeout}from"../../../common/async.js";import{Codicon}from"../../../common/codicons.js";import{ThemeIcon}from"../../../common/themables.js";import{isCancellationError,onUnexpectedError}from"../../../common/errors.js";import{Emitter,Event}from"../../../common/event.js";import{Iterable}from"../../../common/iterator.js";import{DisposableStore,dispose}from"../../../common/lifecycle.js";import{isIterable}from"../../../common/types.js";function createAsyncDataTreeNode(e){return Object.assign(Object.assign({},e),{children:[],refreshPromise:void 0,stale:!0,slow:!1,collapsedByDefault:void 0})}function isAncestor(e,t){return!!t.parent&&(t.parent===e||isAncestor(e,t.parent))}function intersects(e,t){return e===t||isAncestor(e,t)||isAncestor(t,e)}class AsyncDataTreeNodeWrapper{get element(){return this.node.element.element}get children(){return this.node.children.map((e=>new AsyncDataTreeNodeWrapper(e)))}get depth(){return this.node.depth}get visibleChildrenCount(){return this.node.visibleChildrenCount}get visibleChildIndex(){return this.node.visibleChildIndex}get collapsible(){return this.node.collapsible}get collapsed(){return this.node.collapsed}get visible(){return this.node.visible}get filterData(){return this.node.filterData}constructor(e){this.node=e}}class AsyncDataTreeRenderer{constructor(e,t,r){this.renderer=e,this.nodeMapper=t,this.onDidChangeTwistieState=r,this.renderedNodes=new Map,this.templateId=e.templateId}renderTemplate(e){return{templateData:this.renderer.renderTemplate(e)}}renderElement(e,t,r,s){this.renderer.renderElement(this.nodeMapper.map(e),t,r.templateData,s)}renderTwistie(e,t){return e.slow?(t.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading)),!0):(t.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading)),!1)}disposeElement(e,t,r,s){var i,n;null===(n=(i=this.renderer).disposeElement)||void 0===n||n.call(i,this.nodeMapper.map(e),t,r.templateData,s)}disposeTemplate(e){this.renderer.disposeTemplate(e.templateData)}dispose(){this.renderedNodes.clear()}}function asTreeEvent(e){return{browserEvent:e.browserEvent,elements:e.elements.map((e=>e.element))}}function asTreeMouseEvent(e){return{browserEvent:e.browserEvent,element:e.element&&e.element.element,target:e.target}}class AsyncDataTreeElementsDragAndDropData extends ElementsDragAndDropData{constructor(e){super(e.elements.map((e=>e.element))),this.data=e}}function asAsyncDataTreeDragAndDropData(e){return e instanceof ElementsDragAndDropData?new AsyncDataTreeElementsDragAndDropData(e):e}class AsyncDataTreeNodeListDragAndDrop{constructor(e){this.dnd=e}getDragURI(e){return this.dnd.getDragURI(e.element)}getDragLabel(e,t){if(this.dnd.getDragLabel)return this.dnd.getDragLabel(e.map((e=>e.element)),t)}onDragStart(e,t){var r,s;null===(s=(r=this.dnd).onDragStart)||void 0===s||s.call(r,asAsyncDataTreeDragAndDropData(e),t)}onDragOver(e,t,r,s,i=!0){return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(e),t&&t.element,r,s)}drop(e,t,r,s){this.dnd.drop(asAsyncDataTreeDragAndDropData(e),t&&t.element,r,s)}onDragEnd(e){var t,r;null===(r=(t=this.dnd).onDragEnd)||void 0===r||r.call(t,e)}}function asObjectTreeOptions(e){return e&&Object.assign(Object.assign({},e),{collapseByDefault:!0,identityProvider:e.identityProvider&&{getId:t=>e.identityProvider.getId(t.element)},dnd:e.dnd&&new AsyncDataTreeNodeListDragAndDrop(e.dnd),multipleSelectionController:e.multipleSelectionController&&{isSelectionSingleChangeEvent:t=>e.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({},t),{element:t.element})),isSelectionRangeChangeEvent:t=>e.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({},t),{element:t.element}))},accessibilityProvider:e.accessibilityProvider&&Object.assign(Object.assign({},e.accessibilityProvider),{getPosInSet:void 0,getSetSize:void 0,getRole:e.accessibilityProvider.getRole?t=>e.accessibilityProvider.getRole(t.element):()=>"treeitem",isChecked:e.accessibilityProvider.isChecked?t=>{var r;return!!(null===(r=e.accessibilityProvider)||void 0===r?void 0:r.isChecked(t.element))}:void 0,getAriaLabel:t=>e.accessibilityProvider.getAriaLabel(t.element),getWidgetAriaLabel:()=>e.accessibilityProvider.getWidgetAriaLabel(),getWidgetRole:e.accessibilityProvider.getWidgetRole?()=>e.accessibilityProvider.getWidgetRole():()=>"tree",getAriaLevel:e.accessibilityProvider.getAriaLevel&&(t=>e.accessibilityProvider.getAriaLevel(t.element)),getActiveDescendantId:e.accessibilityProvider.getActiveDescendantId&&(t=>e.accessibilityProvider.getActiveDescendantId(t.element))}),filter:e.filter&&{filter:(t,r)=>e.filter.filter(t.element,r)},keyboardNavigationLabelProvider:e.keyboardNavigationLabelProvider&&Object.assign(Object.assign({},e.keyboardNavigationLabelProvider),{getKeyboardNavigationLabel:t=>e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t.element)}),sorter:void 0,expandOnlyOnTwistieClick:void 0===e.expandOnlyOnTwistieClick?void 0:"function"!=typeof e.expandOnlyOnTwistieClick?e.expandOnlyOnTwistieClick:t=>e.expandOnlyOnTwistieClick(t.element),defaultFindVisibility:t=>t.hasChildren&&t.stale?1:"number"==typeof e.defaultFindVisibility?e.defaultFindVisibility:void 0===e.defaultFindVisibility?2:e.defaultFindVisibility(t.element)})}function dfs(e,t){t(e),e.children.forEach((e=>dfs(e,t)))}export class AsyncDataTree{get onDidChangeFocus(){return Event.map(this.tree.onDidChangeFocus,asTreeEvent)}get onDidChangeSelection(){return Event.map(this.tree.onDidChangeSelection,asTreeEvent)}get onMouseDblClick(){return Event.map(this.tree.onMouseDblClick,asTreeMouseEvent)}get onPointer(){return Event.map(this.tree.onPointer,asTreeMouseEvent)}get onDidFocus(){return this.tree.onDidFocus}get onDidChangeModel(){return this.tree.onDidChangeModel}get onDidChangeCollapseState(){return this.tree.onDidChangeCollapseState}get onDidChangeFindOpenState(){return this.tree.onDidChangeFindOpenState}get onDidDispose(){return this.tree.onDidDispose}constructor(e,t,r,s,i,n={}){this.user=e,this.dataSource=i,this.nodes=new Map,this.subTreeRefreshPromises=new Map,this.refreshPromises=new Map,this._onDidRender=new Emitter,this._onDidChangeNodeSlowState=new Emitter,this.nodeMapper=new WeakMapper((e=>new AsyncDataTreeNodeWrapper(e))),this.disposables=new DisposableStore,this.identityProvider=n.identityProvider,this.autoExpandSingleChildren=void 0!==n.autoExpandSingleChildren&&n.autoExpandSingleChildren,this.sorter=n.sorter,this.collapseByDefault=n.collapseByDefault,this.tree=this.createTree(e,t,r,s,n),this.onDidChangeFindMode=this.tree.onDidChangeFindMode,this.root=createAsyncDataTreeNode({element:void 0,parent:null,hasChildren:!0}),this.identityProvider&&(this.root=Object.assign(Object.assign({},this.root),{id:null})),this.nodes.set(null,this.root),this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState,this,this.disposables)}createTree(e,t,r,s,i){const n=new ComposedTreeDelegate(r),o=s.map((e=>new AsyncDataTreeRenderer(e,this.nodeMapper,this._onDidChangeNodeSlowState.event))),a=asObjectTreeOptions(i)||{};return new ObjectTree(e,t,n,o,a)}updateOptions(e={}){this.tree.updateOptions(e)}getHTMLElement(){return this.tree.getHTMLElement()}get scrollTop(){return this.tree.scrollTop}set scrollTop(e){this.tree.scrollTop=e}domFocus(){this.tree.domFocus()}layout(e,t){this.tree.layout(e,t)}style(e){this.tree.style(e)}getInput(){return this.root.element}setInput(e,t){return __awaiter(this,void 0,void 0,(function*(){this.refreshPromises.forEach((e=>e.cancel())),this.refreshPromises.clear(),this.root.element=e;const r=t&&{viewState:t,focus:[],selection:[]};yield this._updateChildren(e,!0,!1,r),r&&(this.tree.setFocus(r.focus),this.tree.setSelection(r.selection)),t&&"number"==typeof t.scrollTop&&(this.scrollTop=t.scrollTop)}))}_updateChildren(e=this.root.element,t=!0,r=!1,s,i){return __awaiter(this,void 0,void 0,(function*(){if(void 0===this.root.element)throw new TreeError(this.user,"Tree input not set");this.root.refreshPromise&&(yield this.root.refreshPromise,yield Event.toPromise(this._onDidRender.event));const n=this.getDataNode(e);if(yield this.refreshAndRenderNode(n,t,s,i),r)try{this.tree.rerender(n)}catch(e){}}))}rerender(e){if(void 0===e||e===this.root.element)return void this.tree.rerender();const t=this.getDataNode(e);this.tree.rerender(t)}getNode(e=this.root.element){const t=this.getDataNode(e),r=this.tree.getNode(t===this.root?null:t);return this.nodeMapper.map(r)}collapse(e,t=!1){const r=this.getDataNode(e);return this.tree.collapse(r===this.root?null:r,t)}expand(e,t=!1){return __awaiter(this,void 0,void 0,(function*(){if(void 0===this.root.element)throw new TreeError(this.user,"Tree input not set");this.root.refreshPromise&&(yield this.root.refreshPromise,yield Event.toPromise(this._onDidRender.event));const r=this.getDataNode(e);if(this.tree.hasElement(r)&&!this.tree.isCollapsible(r))return!1;if(r.refreshPromise&&(yield this.root.refreshPromise,yield Event.toPromise(this._onDidRender.event)),r!==this.root&&!r.refreshPromise&&!this.tree.isCollapsed(r))return!1;const s=this.tree.expand(r===this.root?null:r,t);return r.refreshPromise&&(yield this.root.refreshPromise,yield Event.toPromise(this._onDidRender.event)),s}))}setSelection(e,t){const r=e.map((e=>this.getDataNode(e)));this.tree.setSelection(r,t)}getSelection(){return this.tree.getSelection().map((e=>e.element))}setFocus(e,t){const r=e.map((e=>this.getDataNode(e)));this.tree.setFocus(r,t)}getFocus(){return this.tree.getFocus().map((e=>e.element))}reveal(e,t){this.tree.reveal(this.getDataNode(e),t)}getParentElement(e){const t=this.tree.getParentElement(this.getDataNode(e));return t&&t.element}getFirstElementChild(e=this.root.element){const t=this.getDataNode(e),r=this.tree.getFirstElementChild(t===this.root?null:t);return r&&r.element}getDataNode(e){const t=this.nodes.get(e===this.root.element?null:e);if(!t)throw new TreeError(this.user,`Data tree node not found: ${e}`);return t}refreshAndRenderNode(e,t,r,s){return __awaiter(this,void 0,void 0,(function*(){yield this.refreshNode(e,t,r),this.render(e,r,s)}))}refreshNode(e,t,r){return __awaiter(this,void 0,void 0,(function*(){let s;return this.subTreeRefreshPromises.forEach(((i,n)=>{!s&&intersects(n,e)&&(s=i.then((()=>this.refreshNode(e,t,r))))})),s||(e!==this.root&&this.tree.getNode(e).collapsed?(e.hasChildren=!!this.dataSource.hasChildren(e.element),void(e.stale=!0)):this.doRefreshSubTree(e,t,r))}))}doRefreshSubTree(e,t,r){return __awaiter(this,void 0,void 0,(function*(){let s;e.refreshPromise=new Promise((e=>s=e)),this.subTreeRefreshPromises.set(e,e.refreshPromise),e.refreshPromise.finally((()=>{e.refreshPromise=void 0,this.subTreeRefreshPromises.delete(e)}));try{const i=yield this.doRefreshNode(e,t,r);e.stale=!1,yield Promises.settled(i.map((e=>this.doRefreshSubTree(e,t,r))))}finally{s()}}))}doRefreshNode(e,t,r){return __awaiter(this,void 0,void 0,(function*(){let s;if(e.hasChildren=!!this.dataSource.hasChildren(e.element),e.hasChildren){const t=this.doGetChildren(e);if(isIterable(t))s=Promise.resolve(t);else{const r=timeout(800);r.then((()=>{e.slow=!0,this._onDidChangeNodeSlowState.fire(e)}),(e=>null)),s=t.finally((()=>r.cancel()))}}else s=Promise.resolve(Iterable.empty());try{const i=yield s;return this.setChildren(e,i,t,r)}catch(t){if(e!==this.root&&this.tree.hasElement(e)&&this.tree.collapse(e),isCancellationError(t))return[];throw t}finally{e.slow&&(e.slow=!1,this._onDidChangeNodeSlowState.fire(e))}}))}doGetChildren(e){let t=this.refreshPromises.get(e);if(t)return t;const r=this.dataSource.getChildren(e.element);return isIterable(r)?this.processChildren(r):(t=createCancelablePromise((()=>__awaiter(this,void 0,void 0,(function*(){return this.processChildren(yield r)})))),this.refreshPromises.set(e,t),t.finally((()=>{this.refreshPromises.delete(e)})))}_onDidChangeCollapseState({node:e,deep:t}){null!==e.element&&!e.collapsed&&e.element.stale&&(t?this.collapse(e.element.element):this.refreshAndRenderNode(e.element,!1).catch(onUnexpectedError))}setChildren(e,t,r,s){const i=[...t];if(0===e.children.length&&0===i.length)return[];const n=new Map,o=new Map;for(const t of e.children)if(n.set(t.element,t),this.identityProvider){const e=this.tree.isCollapsed(t);o.set(t.id,{node:t,collapsed:e})}const a=[],l=i.map((t=>{const i=!!this.dataSource.hasChildren(t);if(!this.identityProvider){const r=createAsyncDataTreeNode({element:t,parent:e,hasChildren:i});return i&&this.collapseByDefault&&!this.collapseByDefault(t)&&(r.collapsedByDefault=!1,a.push(r)),r}const l=this.identityProvider.getId(t).toString(),d=o.get(l);if(d){const e=d.node;return n.delete(e.element),this.nodes.delete(e.element),this.nodes.set(t,e),e.element=t,e.hasChildren=i,r?d.collapsed?(e.children.forEach((e=>dfs(e,(e=>this.nodes.delete(e.element))))),e.children.splice(0,e.children.length),e.stale=!0):a.push(e):i&&this.collapseByDefault&&!this.collapseByDefault(t)&&(e.collapsedByDefault=!1,a.push(e)),e}const h=createAsyncDataTreeNode({element:t,parent:e,id:l,hasChildren:i});return s&&s.viewState.focus&&s.viewState.focus.indexOf(l)>-1&&s.focus.push(h),s&&s.viewState.selection&&s.viewState.selection.indexOf(l)>-1&&s.selection.push(h),s&&s.viewState.expanded&&s.viewState.expanded.indexOf(l)>-1?a.push(h):i&&this.collapseByDefault&&!this.collapseByDefault(t)&&(h.collapsedByDefault=!1,a.push(h)),h}));for(const e of n.values())dfs(e,(e=>this.nodes.delete(e.element)));for(const e of l)this.nodes.set(e.element,e);return e.children.splice(0,e.children.length,...l),e!==this.root&&this.autoExpandSingleChildren&&1===l.length&&0===a.length&&(l[0].collapsedByDefault=!1,a.push(l[0])),a}render(e,t,r){const s=e.children.map((e=>this.asTreeElement(e,t))),i=r&&Object.assign(Object.assign({},r),{diffIdentityProvider:r.diffIdentityProvider&&{getId:e=>r.diffIdentityProvider.getId(e.element)}});this.tree.setChildren(e===this.root?null:e,s,i),e!==this.root&&this.tree.setCollapsible(e,e.hasChildren),this._onDidRender.fire()}asTreeElement(e,t){if(e.stale)return{element:e,collapsible:e.hasChildren,collapsed:!0};let r;return r=!(t&&t.viewState.expanded&&e.id&&t.viewState.expanded.indexOf(e.id)>-1)&&e.collapsedByDefault,e.collapsedByDefault=void 0,{element:e,children:e.hasChildren?Iterable.map(e.children,(e=>this.asTreeElement(e,t))):[],collapsible:e.hasChildren,collapsed:r}}processChildren(e){return this.sorter&&(e=[...e].sort(this.sorter.compare.bind(this.sorter))),e}dispose(){this.disposables.dispose()}}class CompressibleAsyncDataTreeNodeWrapper{get element(){return{elements:this.node.element.elements.map((e=>e.element)),incompressible:this.node.element.incompressible}}get children(){return this.node.children.map((e=>new CompressibleAsyncDataTreeNodeWrapper(e)))}get depth(){return this.node.depth}get visibleChildrenCount(){return this.node.visibleChildrenCount}get visibleChildIndex(){return this.node.visibleChildIndex}get collapsible(){return this.node.collapsible}get collapsed(){return this.node.collapsed}get visible(){return this.node.visible}get filterData(){return this.node.filterData}constructor(e){this.node=e}}class CompressibleAsyncDataTreeRenderer{constructor(e,t,r,s){this.renderer=e,this.nodeMapper=t,this.compressibleNodeMapperProvider=r,this.onDidChangeTwistieState=s,this.renderedNodes=new Map,this.disposables=[],this.templateId=e.templateId}renderTemplate(e){return{templateData:this.renderer.renderTemplate(e)}}renderElement(e,t,r,s){this.renderer.renderElement(this.nodeMapper.map(e),t,r.templateData,s)}renderCompressedElements(e,t,r,s){this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(e),t,r.templateData,s)}renderTwistie(e,t){return e.slow?(t.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading)),!0):(t.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading)),!1)}disposeElement(e,t,r,s){var i,n;null===(n=(i=this.renderer).disposeElement)||void 0===n||n.call(i,this.nodeMapper.map(e),t,r.templateData,s)}disposeCompressedElements(e,t,r,s){var i,n;null===(n=(i=this.renderer).disposeCompressedElements)||void 0===n||n.call(i,this.compressibleNodeMapperProvider().map(e),t,r.templateData,s)}disposeTemplate(e){this.renderer.disposeTemplate(e.templateData)}dispose(){this.renderedNodes.clear(),this.disposables=dispose(this.disposables)}}function asCompressibleObjectTreeOptions(e){const t=e&&asObjectTreeOptions(e);return t&&Object.assign(Object.assign({},t),{keyboardNavigationLabelProvider:t.keyboardNavigationLabelProvider&&Object.assign(Object.assign({},t.keyboardNavigationLabelProvider),{getCompressedNodeKeyboardNavigationLabel:t=>e.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(t.map((e=>e.element)))})})}export class CompressibleAsyncDataTree extends AsyncDataTree{constructor(e,t,r,s,i,n,o={}){super(e,t,r,i,n,o),this.compressionDelegate=s,this.compressibleNodeMapper=new WeakMapper((e=>new CompressibleAsyncDataTreeNodeWrapper(e))),this.filter=o.filter}createTree(e,t,r,s,i){const n=new ComposedTreeDelegate(r),o=s.map((e=>new CompressibleAsyncDataTreeRenderer(e,this.nodeMapper,(()=>this.compressibleNodeMapper),this._onDidChangeNodeSlowState.event))),a=asCompressibleObjectTreeOptions(i)||{};return new CompressibleObjectTree(e,t,n,o,a)}asTreeElement(e,t){return Object.assign({incompressible:this.compressionDelegate.isIncompressible(e.element)},super.asTreeElement(e,t))}updateOptions(e={}){this.tree.updateOptions(e)}render(e,t){if(!this.identityProvider)return super.render(e,t);const r=e=>this.identityProvider.getId(e).toString(),s=e=>{const t=new Set;for(const s of e){const e=this.tree.getCompressedTreeNode(s===this.root?null:s);if(e.element)for(const s of e.element.elements)t.add(r(s.element))}return t},i=s(this.tree.getSelection()),n=s(this.tree.getFocus());super.render(e,t);const o=this.getSelection();let a=!1;const l=this.getFocus();let d=!1;const h=e=>{const t=e.element;if(t)for(let e=0;e<t.elements.length;e++){const s=r(t.elements[e].element),h=t.elements[t.elements.length-1].element;i.has(s)&&-1===o.indexOf(h)&&(o.push(h),a=!0),n.has(s)&&-1===l.indexOf(h)&&(l.push(h),d=!0)}e.children.forEach(h)};h(this.tree.getCompressedTreeNode(e===this.root?null:e)),a&&this.setSelection(o),d&&this.setFocus(l)}processChildren(e){return this.filter&&(e=Iterable.filter(e,(e=>{const t=getVisibility(this.filter.filter(e,1));if(2===t)throw new Error("Recursive tree visibility not supported in async data compressed trees");return 1===t}))),super.processChildren(e)}}function getVisibility(e){return"boolean"==typeof e?e?1:0:isFilterResult(e)?getVisibleState(e.visibility):getVisibleState(e)}