"use strict";(self.webpackChunkmy_application=self.webpackChunkmy_application||[]).push([[6040],{6040:(n,o,t)=>{t.r(o),t.d(o,{default:()=>e});const e="// A fragment shader which lights textured geometry with point lights.\n// Taken from the introduction of the WebGPU Shading Lnaguage Specification\n// https://w3.org/TR/WGSL\n\n// Lights from a storage buffer binding.\nstruct PointLight {\n  position : vec3f,\n  color : vec3f,\n}\n\nstruct LightStorage {\n  pointCount : u32,\n  point : array<PointLight>,\n}\n@group(0) @binding(0) var<storage> lights : LightStorage;\n\n// Texture and sampler.\n@group(1) @binding(0) var baseColorSampler : sampler;\n@group(1) @binding(1) var baseColorTexture : texture_2d<f32>;\n\n// Function arguments are values from from vertex shader.\n@fragment\nfn fragmentMain(@location(0) worldPos : vec3f,\n                @location(1) normal : vec3f,\n                @location(2) uv : vec2f) -> @location(0) vec4f {\n  // Sample the base color of the surface from a texture.\n  let baseColor = textureSample(baseColorTexture, baseColorSampler, uv);\n\n  let N = normalize(normal);\n  var surfaceColor = vec3f(0);\n\n  // Loop over the scene point lights.\n  for (var i = 0u; i < lights.pointCount; i++) {\n    let worldToLight = lights.point[i].position - worldPos;\n    let dist = length(worldToLight);\n    let dir = normalize(worldToLight);\n\n    // Determine the contribution of this light to the surface color.\n    let radiance = lights.point[i].color * (1 / pow(dist, 2));\n    let nDotL = max(dot(N, dir), 0);\n\n    // Accumulate light contribution to the surface color.\n    surfaceColor += baseColor.rgb * radiance * nDotL;\n  }\n\n  // Return the accumulated surface color.\n  return vec4(surfaceColor, baseColor.a);\n}\n"}}]);
//# sourceMappingURL=6040.js.map