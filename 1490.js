"use strict";(self.webpackChunkmy_application=self.webpackChunkmy_application||[]).push([[1490],{1490:(n,e,t)=>{t.r(e),t.d(e,{default:()=>a});const a='# Elixir is a dynamic, functional language for building scalable\n# and maintainable applications. Learn more: https://elixir-lang.org\n\n"Elixir" |> String.graphemes() |> Enum.frequencies()\n#=> %{"E" => 1, "i" => 2, "l" => 1, "r" => 1, "x" => 1}\n\n\n### Scalability ###\n\n# All Elixir code runs inside lightweight threads of execution (called processes)\n# that are isolated and exchange information via messages:\n\ncurrent_process = self()\n\n# Spawn an Elixir process (not an operating system one!)\nspawn_link(fn ->\n  send(current_process, {:msg, "hello world"})\nend)\n\n# Block until the message is received\nreceive do\n  {:msg, contents} -> IO.puts(contents)\nend\n\n\n### Fault-tolerance ###\n\n# To cope with failures, Elixir provides supervisors which describe\n# how to restart parts of your system when things go awry, going back\n# to a known initial state that is guaranteed to work:\n\nchildren = [\n  TCP.Pool,\n  {TCP.Acceptor, port: 4040}\n]\n\nSupervisor.start_link(children, strategy: :one_for_one)\n\n\n### Functional programming ###\n\n# Functional programming promotes a coding style that helps\n# developers write code that is short, concise, and maintainable.\n# One prominent example is pattern matching:\n\n%User{name: name, age: age} = User.get("John Doe")\nname #=> "John Doe"\n\n# When mixed with guards, pattern matching allows us to elegantly\n# match and assert specific conditions for some code to execute:\n\ndef drive(%User{age: age}) when age >= 16 do\n  # Code that drives a car\nend\n\ndrive(User.get("John Doe"))\n#=> Fails if the user is under 16\n\n\n### Extensibility and DSLs ###\n\n# Elixir has been designed to be extensible, letting developers\n# naturally extend the language to particular domains,\n# in order to increase their productivity.\n\ndefmodule MathTest do\n  use ExUnit.Case, async: true\n\n  test "can add two numbers" do\n    assert 1 + 1 == 2\n  end\nend\n\n\n### Erlang compatible ###\n\n# An Elixir programmer can invoke any Erlang function with no runtime cost:\n\n:crypto.hash(:md5, "Using crypto from Erlang OTP")\n#=> <<192, 223, 75, 115, ...>>\n'}}]);
//# sourceMappingURL=1490.js.map